/**
 * Defines a GROQ query string literal type. This no-op function helps TypeScript
 * preserve the exact query structure for type inference when working with
 * {@link SanityQueryResult} and query type generation. While similar to the `groq`
 * template tag, this function enables better type inference until TypeScript
 * resolves microsoft/TypeScript#33304.
 *
 * @param query - The GROQ query to capture as a literal type
 * @returns The same query string unchanged
 *
 * @example
 * ```ts
 * const authorQuery = defineQuery('*[_type == "author"]')
 * type AuthorResult = SanityQueryResult<typeof authorQuery>
 * ```
 * @public
 */
export function defineQuery<const TQuery extends string>(query: TQuery): TQuery {
  return query
}

/**
 * This interface is augmented by [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to
 * provide type definitions for registered GROQ queries. This allows library authors to capture the
 * query string as a literal and look up type of the query result via importing this augmented
 * interface.
 *
 * See {@link SanityQueryResult}.
 *
 * @example
 * ```ts
 * export type AuthorsQueryResult = {
 *   // ...
 * }[]
 *
 * declare module 'groq' {
 *  interface SanityQueries {
 *   '*[_type=="author"]': AuthorsQueryResult
 *  }
 * }
 * ```
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface SanityQueries {}

/**
 * This interface is augmented by the [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to
 * provide type definitions for all schema types registered by the user. This allows extracting
 * specific schema types using helpers like {@link SanitySchema}, {@link SanityDocument}, or
 * {@link SanitySchemaType}.
 *
 * For most users with a single schema, the type generator will augment this interface to declare a
 * `DefaultSchema` type and register it under the key `'default'`. In multi-schema setups
 * (experimental), each schema would be registered with its own unique schema ID.
 *
 * @example
 * ```ts
 * // In a single-schema setup:
 * type Author = {_id: string; _type: 'author'; name: string}
 * type Book = {_id: string; _type: 'book'; title: string}
 *
 * type DefaultSchema = Author | Book
 *
 * declare module 'groq' {
 *   interface SanitySchemas {
 *     default: DefaultSchema
 *   }
 * }
 * ```
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface SanitySchemas {}

/**
 * Extracts a schema type by its ID. By default, it will resolve to the
 * `DefaultSchema` generated by default by the type generator.
 *
 * @typeParam TSchemaId - The schema ID to extract (experimental)
 *
 * @example
 * ```ts
 * type MySchema = SanitySchema<'default'>
 * // Returns union of all types in the default schema
 * ```
 * @public
 */
export type SanitySchema<TSchemaId extends string = string> = PickSchema<
  SafeAccess<SanitySchemas, TSchemaId>,
  TSchemaId
>

interface SanityDocumentBase {
  _id: string
  _type: string
  _createdAt: string
  _updatedAt: string
  _rev: string
  [key: string]: unknown
}

/**
 * Represents a Sanity document with base document fields. Used as the foundation
 * for document type definitions.
 *
 * @typeParam TDocumentType - The _type field value of the document
 * @typeParam TSchemaId - The schema ID to pick from (experimental)
 *
 * @example
 * ```ts
 * type AuthorDoc = SanityDocument<'author'>
 * // Returns: Author type with `_id`, `_type`, etc.
 * ```
 * @public
 */
export type SanityDocument<
  TDocumentType extends string = string,
  TSchemaId extends string = string,
> = Extract<
  Extract<SanitySchema<TSchemaId>, SanityDocumentBase> | SanityDocumentBase,
  {_type: TDocumentType}
>

/**
 * Extracts a specific schema type by both schema ID and type name. Combines
 * schema selection with type filtering.
 *
 * @typeParam TSchemaTypeName - The _type field value to match
 * @typeParam TSchemaId - The schema ID to pick from  (experimental)
 *
 * @example
 * ```ts
 * type AuthorType = SanitySchemaType<'author'>
 * // Returns: Author type
 * ```
 * @public
 */
export type SanitySchemaType<
  TSchemaTypeName extends string = string,
  TSchemaId extends string = string,
> = Extract<SanitySchema<TSchemaId>, {_type: TSchemaTypeName}>

type SafeAccess<T, K extends string> = K extends keyof T ? T[K] : T[keyof T]

/**
 * Represents the result type of a GROQ query. Combines schema picking with
 * query result type resolution.
 *
 * @typeParam TQuery - The GROQ query string literal type
 * @typeParam TSchemaId - The schema ID to pick from
 *
 * @example
 * ```ts
 * type Result = SanityQueryResult<'*[_type=="author"]'>
 * // Returns: Author[] from the schema
 * ```
 * @public
 */
export type SanityQueryResult<
  TQuery extends string = string,
  TSchemaId extends string = string,
> = PickSchema<SafeAccess<SanityQueries, TQuery>, TSchemaId>

/**
 * @experimental
 * A helper type that tags a base type with a schema ID. This is used internally
 * by other helpers to enable schema-aware type inference.
 *
 * @typeParam TBase - The base type to tag.
 * @typeParam TSchemaId - The schema ID to associate with the type.
 * @internal
 */
type SchemaOrigin<TBase, TSchemaId extends string> = TBase & {
  /**
   * @internal
   * @deprecated typescript helper only
   */
  readonly __schemaId?: TSchemaId
}

/**
 * @experimental
 * Extracts types from a schema-aware union that match a specific schema ID.
 * Useful when working with multi-schema environments.
 *
 * @typeParam T - Union type containing SchemaOrigin types
 * @typeParam TSchemaId - The schema ID to filter by
 *
 * @example
 * ```ts
 * // As generated in explain.sanity.types.ts:
 * type Author =
 *   SchemaOrigin<{_type: 'author'; foo: string}, 'yourProjectId.test'> |
 *   SchemaOrigin<{_type: 'author'; foo: number}, 'yourProjectId.production'>
 *
 * // Extract production version:
 * type ProductionAuthor = PickSchema<Author, 'yourProjectId.production'>
 * // Returns: {_type: 'author'; foo: number}
 * ```
 * @internal
 */
type PickSchema<T, TSchemaId extends string = string> = Extract<T, SchemaOrigin<T, TSchemaId>>
