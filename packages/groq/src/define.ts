/**
 * Defines a GROQ query string literal type. This no-op function helps TypeScript
 * preserve the exact query structure for type inference when working with
 * {@link SanityQueryResult} and query type generation. While similar to the `groq`
 * template tag, this function enables better type inference until TypeScript
 * resolves microsoft/TypeScript#33304.
 *
 * @param query - The GROQ query to capture as a literal type
 * @returns The same query string unchanged
 *
 * @example
 * ```ts
 * const authorQuery = defineQuery('*[_type == "author"]')
 * type AuthorResult = SanityQueryResult<typeof authorQuery>
 * ```
 * @public
 */
export function defineQuery<const TQuery extends string>(query: TQuery): TQuery {
  return query
}

/**
 * An identity function that can be used to get TypeScript types for a GROQ projection.
 * At runtime, this function is a no-op and returns the `projection` string unmodified.
 * Its primary purpose is to serve as a hook for Sanity's TypeGen to generate types.
 * The `_documentTypeBase` parameter is unused at runtime but is required by TypeGen
 * to know which document type(s) to compute the projection against.
 *
 * @example
 * ```ts
 * import {defineDocumentProjection} from 'groq'
 *
 * export const postProjection = defineDocumentProjection(
 *   'post',
 *   '{_id, title, author->}',
 * )
 *
 * // When code generation is run, the following will be available:
 * // import {SanityDocumentProjectionResult} from 'groq'
 * // type PostProjection = SanityDocumentProjectionResult<typeof postProjection>
 * ```
 *
 * @public
 */
export function defineDocumentProjection<const TDocumentProjection extends string>(
  _documentTypeBase: string | string[],
  projection: TDocumentProjection,
): TDocumentProjection {
  return projection
}

/**
 * A branded type that associates a projection result with its base document type.
 * This type is exported in the generated `sanity.types.ts` file and allows for
 * type narrowing when the same projection string is used across different document types.
 *
 * The `TDocumentType` parameter enables consumers to narrow down union types when
 * a projection is defined for multiple document types. For example, if a projection
 * `{_id, title}` is used for both `post` and `article` document types, the type
 * generator creates a union, but consumers can extract specific document types
 * using the branded type information.
 *
 * @typeParam T - The projection result type (the shape of the projected fields)
 * @typeParam TDocumentType - The specific document type this projection result is based on
 *
 * @example
 * ```ts
 * // Generated type for a projection used on multiple document types:
 * type ContentProjectionResult =
 *   | DocumentProjectionBase<{
 *       _type: "post";
 *       _id: string;
 *       content: PortableTextBlock[]; // PTE field in post
 *     }, "post">
 *   | DocumentProjectionBase<{
 *       _type: "article";
 *       _id: string;
 *       content: string; // Plain string in article
 *     }, "article">
 *
 * // Consumer can narrow to specific document type if needed
 * type PostContentOnly = SanityDocumentProjectionResult<"{_type, _id, content}", "post">
 * // Result: {_type: "post"; _id: string; content: PortableTextBlock[]}
 * ```
 *
 * @public
 */
export type DocumentProjectionBase<T, TDocumentType extends string> = T & {
  readonly __documentTypeBase?: TDocumentType
}

type PickDocumentProjection<T, TDocumentType extends string> = Extract<
  T,
  DocumentProjectionBase<T, TDocumentType>
>

/**
 * A helper type that looks up the result type of a document projection.
 * This type resolves document projections defined with `defineDocumentProjection`
 * to their corresponding TypeScript types generated by Sanity TypeGen.
 *
 * When a projection string is used across multiple document types, this helper
 * can narrow the union down to a specific document type using the `TDocumentType`
 * parameter, which is useful when the same projection yields different shapes
 * for different document types.
 *
 * @typeParam TDocumentProjection - The projection string literal type
 * @typeParam TDocumentType - Optional document type to narrow the result to a specific type
 * @typeParam TSchemaId - The schema ID to pick from (experimental)
 *
 * @example
 * ```ts
 * import {defineDocumentProjection, SanityDocumentProjectionResult} from 'groq'
 *
 * // Define a projection that works on multiple document types
 * const contentProjection = defineDocumentProjection(['post', 'article'], '{_type, _id, content}')
 *
 * // Get the union of all possible results
 * type ContentProjection = SanityDocumentProjectionResult<typeof contentProjection>
 * // Result: {_type: "post"; _id: string; content: PortableTextBlock[]} |
 * //         {_type: "article"; _id: string; content: string}
 *
 * // Narrow to a specific document type
 * type PostContentOnly = SanityDocumentProjectionResult<typeof contentProjection, "post">
 * // Result: {_type: "post"; _id: string; content: PortableTextBlock[]}
 * ```
 *
 * @public
 */
export type SanityDocumentProjectionResult<
  TDocumentProjection extends string,
  TDocumentType extends string = string,
  TSchemaId extends string = string,
> = PickSchema<
  PickDocumentProjection<SafeAccess<SanityDocumentProjections, TDocumentProjection>, TDocumentType>,
  TSchemaId
>

/**
 * This interface is augmented by [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to
 * provide type definitions for registered GROQ document projections. Each projection string
 * is mapped to its corresponding result type, with unions created when the same projection
 * is used across multiple document types with different field shapes.
 *
 * @example
 * ```ts
 * // Generated types for projections with different shapes per document type
 * export type ContentProjectionResult =
 *   | DocumentProjectionBase<{_type: "post"; _id: string; content: PortableTextBlock[]}, "post">
 *   | DocumentProjectionBase<{_type: "article"; _id: string; content: string}, "article">
 *
 * export type TitleProjectionResult = DocumentProjectionBase<{
 *   _type: "post";
 *   _id: string;
 *   title: string | null;
 * }, "post">
 *
 * // Module augmentation mapping projection strings to result types
 * declare module 'groq' {
 *   interface SanityDocumentProjections {
 *     '{_type, _id, content}': ContentProjectionResult  // Union for multiple doc types
 *     '{_id, title}': TitleProjectionResult            // Single doc type
 *   }
 * }
 * ```
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface SanityDocumentProjections {}

/**
 * This interface is augmented by [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to
 * provide type definitions for registered GROQ queries. This allows library authors to capture the
 * query string as a literal and look up type of the query result via importing this augmented
 * interface.
 *
 * See {@link SanityQueryResult}.
 *
 * @example
 * ```ts
 * export type AuthorsQueryResult = {
 *   // ...
 * }[]
 *
 * declare module 'groq' {
 *  interface SanityQueries {
 *   '*[_type=="author"]': AuthorsQueryResult
 *  }
 * }
 * ```
 *
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface SanityQueries {}

/**
 * This interface is augmented by the [Sanity TypeGen](https://www.sanity.io/docs/sanity-typegen) to
 * provide type definitions for all schema types registered by the user. This allows extracting
 * specific schema types using helpers like {@link SanitySchema}, {@link SanityDocument}, or
 * {@link SanitySchemaType}.
 *
 * For most users with a single schema, the type generator will augment this interface to declare a
 * `DefaultSchema` type and register it under the key `'default'`. In multi-schema setups
 * (experimental), each schema would be registered with its own unique schema ID.
 *
 * @example
 * ```ts
 * // In a single-schema setup:
 * type Author = {_id: string; _type: 'author'; name: string}
 * type Book = {_id: string; _type: 'book'; title: string}
 *
 * type DefaultSchema = Author | Book
 *
 * declare module 'groq' {
 *   interface SanitySchemas {
 *     default: DefaultSchema
 *   }
 * }
 * ```
 * @public
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface SanitySchemas {}

/**
 * Extracts a schema type by its ID. By default, it will resolve to the
 * `DefaultSchema` generated by default by the type generator.
 *
 * @typeParam TSchemaId - The schema ID to extract (experimental)
 *
 * @example
 * ```ts
 * type MySchema = SanitySchema<'default'>
 * // Returns union of all types in the default schema
 * ```
 * @public
 */
export type SanitySchema<TSchemaId extends string = string> = PickSchema<
  SafeAccess<SanitySchemas, TSchemaId>,
  TSchemaId
>

interface SanityDocumentBase {
  _id: string
  _type: string
  _createdAt: string
  _updatedAt: string
  _rev: string
  [key: string]: unknown
}

/**
 * Represents a Sanity document with base document fields. Used as the foundation
 * for document type definitions.
 *
 * @typeParam TDocumentType - The _type field value of the document
 * @typeParam TSchemaId - The schema ID to pick from (experimental)
 *
 * @example
 * ```ts
 * type AuthorDoc = SanityDocument<'author'>
 * // Returns: Author type with `_id`, `_type`, etc.
 * ```
 * @public
 */
export type SanityDocument<
  TDocumentType extends string = string,
  TSchemaId extends string = string,
> = Extract<
  Extract<SanitySchema<TSchemaId>, SanityDocumentBase> | SanityDocumentBase,
  {_type: TDocumentType}
>

/**
 * Extracts a specific schema type by both schema ID and type name. Combines
 * schema selection with type filtering.
 *
 * @typeParam TSchemaTypeName - The _type field value to match
 * @typeParam TSchemaId - The schema ID to pick from  (experimental)
 *
 * @example
 * ```ts
 * type AuthorType = SanitySchemaType<'author'>
 * // Returns: Author type
 * ```
 * @public
 */
export type SanitySchemaType<
  TSchemaTypeName extends string = string,
  TSchemaId extends string = string,
> = Extract<SanitySchema<TSchemaId>, {_type: TSchemaTypeName}>

type SafeAccess<T, K extends string> = K extends keyof T ? T[K] : T[keyof T]

/**
 * Represents the result type of a GROQ query. Combines schema picking with
 * query result type resolution.
 *
 * @typeParam TQuery - The GROQ query string literal type
 * @typeParam TSchemaId - The schema ID to pick from
 *
 * @example
 * ```ts
 * type Result = SanityQueryResult<'*[_type=="author"]'>
 * // Returns: Author[] from the schema
 * ```
 * @public
 */
export type SanityQueryResult<
  TQuery extends string = string,
  TSchemaId extends string = string,
> = PickSchema<SafeAccess<SanityQueries, TQuery>, TSchemaId>

/**
 * @experimental
 * A helper type that tags a base type with a schema ID. This is used internally
 * by other helpers to enable schema-aware type inference.
 *
 * @typeParam TBase - The base type to tag.
 * @typeParam TSchemaId - The schema ID to associate with the type.
 * @internal
 */
type SchemaOrigin<TBase, TSchemaId extends string> = TBase & {
  /**
   * @internal
   * @deprecated typescript helper only
   */
  readonly __schemaId?: TSchemaId
}

/**
 * @experimental
 * Extracts types from a schema-aware union that match a specific schema ID.
 * Useful when working with multi-schema environments.
 *
 * @typeParam T - Union type containing SchemaOrigin types
 * @typeParam TSchemaId - The schema ID to filter by
 *
 * @example
 * ```ts
 * // As generated in explain.sanity.types.ts:
 * type Author =
 *   SchemaOrigin<{_type: 'author'; foo: string}, 'yourProjectId.test'> |
 *   SchemaOrigin<{_type: 'author'; foo: number}, 'yourProjectId.production'>
 *
 * // Extract production version:
 * type ProductionAuthor = PickSchema<Author, 'yourProjectId.production'>
 * // Returns: {_type: 'author'; foo: number}
 * ```
 * @internal
 */
type PickSchema<T, TSchemaId extends string = string> = Extract<T, SchemaOrigin<T, TSchemaId>>
