import {mkdir, writeFile} from 'node:fs/promises'
import {dirname, isAbsolute, join} from 'node:path'
import {env} from 'node:process'
import {Worker} from 'node:worker_threads'

import {type TypeGenConfig} from '@sanity/codegen'
import {WorkerChannelReceiver} from '@sanity/worker-channels'
import {type FSWatcher} from 'chokidar'

import {type CliOutputter} from '../../types'
import {getCliWorkerPath} from '../../util/cliWorker'
import {
  type TypegenGenerateTypesWorkerData,
  type TypegenWorkerChannel,
} from '../../workers/typegenGenerate'
import {createTypegenWatcher} from './watchTypegen'

const generatedFileWarning = `/**
 * ---------------------------------------------------------------------------------
 * This file has been generated by Sanity TypeGen.
 * Command: \`sanity typegen generate\`
 *
 * Any modifications made directly to this file will be overwritten the next time
 * the TypeScript definitions are generated. Please make changes to the Sanity
 * schema definitions and/or GROQ queries if you need to update these types.
 *
 * For more information on how to use Sanity TypeGen, visit the official documentation:
 * https://www.sanity.io/docs/sanity-typegen
 * ---------------------------------------------------------------------------------
 */\n\n`

const getMessage = (error: unknown) =>
  typeof error === 'object' && !!error && 'message' in error && typeof error.message === 'string'
    ? error.message
    : 'Unknown error'

interface OnGenerationCallbackData {
  success: boolean
  duration: number
}

/** Options for generating types to a file */
export interface GenerateTypesOptions {
  workDir: string
  schemaPath: string
  searchPath: string | string[]
  outputPath: string
  overloadClientMethods?: boolean
  formatGeneratedCode?: boolean
}

/** Result from a type generation */
export interface GenerateTypesResult {
  code: string
  queriesCount: number
  schemaTypesCount: number
  queryFilesCount: number
  filesWithErrors: number
  typeNodesGenerated: number
  unknownTypeNodesGenerated: number
  emptyUnionTypeNodesGenerated: number
}

/**
 * Generates types to a file. Runs in a worker thread for isolation.
 * Returns the generation result after completion.
 */
export async function generateTypesToFile(
  options: GenerateTypesOptions,
  output: CliOutputter,
): Promise<GenerateTypesResult> {
  const {
    workDir,
    schemaPath,
    searchPath,
    outputPath,
    overloadClientMethods = true,
    formatGeneratedCode = true,
  } = options

  const outputDir = dirname(outputPath)
  await mkdir(outputDir, {recursive: true})

  const workerPath = await getCliWorkerPath('typegenGenerate')
  const workerData: TypegenGenerateTypesWorkerData = {
    workDir,
    schemaPath,
    searchPath,
    overloadClientMethods,
  }
  const worker = new Worker(workerPath, {workerData, env})
  const receiver = WorkerChannelReceiver.from<TypegenWorkerChannel>(worker)

  try {
    await receiver.event.loadedSchema()

    const {expectedFileCount} = await receiver.event.typegenStarted()
    const {schemaTypeDeclarations} = await receiver.event.generatedSchemaTypes()
    const schemaTypesCount = schemaTypeDeclarations.length

    let queriesCount = 0
    let filesWithErrors = 0
    let queryFilesCount = 0
    let typeNodesGenerated = 0
    let unknownTypeNodesGenerated = 0
    let emptyUnionTypeNodesGenerated = 0

    for await (const {queries, errors} of receiver.stream.evaluatedModules()) {
      queriesCount += queries.length
      queryFilesCount += queries.length ? 1 : 0
      filesWithErrors += errors.length ? 1 : 0

      for (const {stats} of queries) {
        typeNodesGenerated += stats.allTypes
        unknownTypeNodesGenerated += stats.unknownTypes
        emptyUnionTypeNodesGenerated += stats.emptyUnions
      }

      for (const error of errors) {
        output.error(getMessage(error))
      }
    }

    const result = await receiver.event.typegenComplete()
    let code = `${generatedFileWarning}${result.code}`

    if (formatGeneratedCode) {
      try {
        const prettier = await import('prettier')
        const prettierConfig = await prettier.resolveConfig(outputPath)
        code = await prettier.format(code, {
          ...prettierConfig,
          parser: 'typescript' as const,
        })
      } catch (err) {
        output.warn(`Failed to format generated types with prettier: ${getMessage(err)}`)
      }
    }

    await writeFile(outputPath, code)

    return {
      code,
      queriesCount,
      schemaTypesCount,
      queryFilesCount,
      filesWithErrors,
      typeNodesGenerated,
      unknownTypeNodesGenerated,
      emptyUnionTypeNodesGenerated,
    }
  } finally {
    receiver.unsubscribe()
    await worker.terminate()
  }
}

/** Options for starting a typegen watcher */
export interface TypegenWatcherOptions {
  workDir: string
  config: TypeGenConfig
  configMethod: 'legacy' | 'cli'
  output: CliOutputter
  debounceMs?: number
  /** Optional callback function for listening in on the type generation */
  onGeneration?: (result: OnGenerationCallbackData) => void
}

/** Result from starting a typegen watcher */
export interface TypegenWatcherResult {
  /** Call to stop the watcher */
  stop: () => Promise<void>
  /** The underlying FSWatcher instance */
  watcher: FSWatcher
}

/**
 * Starts a typegen watcher that generates types on file changes.
 * Watches both query files (based on config.path) and the schema JSON file.
 * Runs an initial generation before starting to watch.
 * Returns a cleanup function to stop the watcher.
 */
export async function startTypegenWatcher(
  options: TypegenWatcherOptions,
): Promise<TypegenWatcherResult> {
  const {workDir, config, output, onGeneration} = options

  const outputPath = isAbsolute(config.generates)
    ? config.generates
    : join(workDir, config.generates)

  // Build query patterns from config.path
  const queryPatterns = Array.isArray(config.path) ? config.path : [config.path]

  // Helper to run generation with spinner and error display
  const runGeneration = async (spinnerText: string, successText: string): Promise<boolean> => {
    const spinner = output.spinner({}).start(spinnerText)
    const startTime = Date.now()

    try {
      const result = await generateTypesToFile(
        {
          workDir,
          schemaPath: config.schema,
          searchPath: config.path,
          outputPath,
          overloadClientMethods: config.overloadClientMethods,
          formatGeneratedCode: config.formatGeneratedCode,
        },
        output,
      )

      onGeneration?.({success: true, duration: Date.now() - startTime})

      if (result.filesWithErrors > 0) {
        spinner.warn(
          `${successText} (with errors in ${result.filesWithErrors} file${result.filesWithErrors === 1 ? '' : 's'})`,
        )
      } else {
        spinner.succeed(successText)
      }
      return true
    } catch (err) {
      onGeneration?.({success: false, duration: Date.now() - startTime})
      spinner.fail(`Generation failed: ${err instanceof Error ? err.message : String(err)}`)
      return false
    }
  }

  // Run initial generation
  await runGeneration('Generating types...', `Generated types to ${config.generates}`)

  // Create generation callback for watch mode
  const onGenerate = async () => {
    await runGeneration('Generating types...', `Generated types to ${config.generates}`)
  }

  // Start watcher
  const watcher = await createTypegenWatcher({
    workDir,
    queryPatterns,
    schemaPath: config.schema,
    onGenerate,
    output,
  })

  const stop = async () => {
    await watcher.close()
  }

  return {stop, watcher}
}
