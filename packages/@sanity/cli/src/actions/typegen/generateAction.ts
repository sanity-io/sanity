/* eslint-disable max-statements */
import {mkdir, stat, writeFile} from 'node:fs/promises'
import {dirname, isAbsolute, join} from 'node:path'
import {env} from 'node:process'
import {Worker} from 'node:worker_threads'

import {configDefinition, readConfig, type TypeGenConfig} from '@sanity/codegen'
import {WorkerChannelReceiver} from '@sanity/worker-channels'
import chalk from 'chalk'

import {type CliCommandArguments, type CliCommandContext} from '../../types'
import {getCliWorkerPath} from '../../util/cliWorker'
import {getCliConfig} from '../../util/getCliConfig'
import {
  type TypegenGenerateTypesWorkerData,
  type TypegenWorkerChannel,
} from '../../workers/typegenGenerate'
import {TypesGeneratedTrace} from './generate.telemetry'

export interface TypegenGenerateTypesCommandFlags {
  'config-path'?: string
}

const generatedFileWarning = `/**
 * ---------------------------------------------------------------------------------
 * This file has been generated by Sanity TypeGen.
 * Command: \`sanity typegen generate\`
 *
 * Any modifications made directly to this file will be overwritten the next time
 * the TypeScript definitions are generated. Please make changes to the Sanity
 * schema definitions and/or GROQ queries if you need to update these types.
 *
 * For more information on how to use Sanity TypeGen, visit the official documentation:
 * https://www.sanity.io/docs/sanity-typegen
 * ---------------------------------------------------------------------------------
 */\n\n`

async function getConfig(
  workDir: string,
  configPath?: string,
): Promise<{config: TypeGenConfig; path?: string; type: 'legacy' | 'cli'}> {
  const config = await getCliConfig(workDir)

  // check if the legacy config exist
  const legacyConfigPath = configPath || 'sanity-typegen.json'
  let hasLegacyConfig = false
  try {
    const file = await stat(legacyConfigPath)
    hasLegacyConfig = file.isFile()
  } catch (err) {
    if (err.code === 'ENOENT' && configPath) {
      throw new Error(`Typegen config file not found: ${configPath}`, {cause: err})
    }

    if (err.code !== 'ENOENT') {
      throw new Error(`Error when checking if typegen config file exists: ${legacyConfigPath}`, {
        cause: err,
      })
    }
  }

  // we have both legacy and cli config with typegen
  if (config?.config?.typegen && hasLegacyConfig) {
    console.warn(
      chalk.yellow(
        `You've specified typegen in your Sanity CLI config, but also have a typegen config.

The config from the Sanity CLI config is used.
`,
      ),
    )

    return {
      config: configDefinition.parse(config.config.typegen || {}),
      path: config.path,
      type: 'cli',
    }
  }

  // we only have legacy typegen config
  if (hasLegacyConfig) {
    console.warn(
      chalk.yellow(
        `The separate typegen config has been deprecated. Use \`typegen\` in the sanity CLI config instead.

See: https://www.sanity.io/docs/help/configuring-typegen-in-sanity-cli-config`,
      ),
    )
    return {
      config: await readConfig(legacyConfigPath),
      path: legacyConfigPath,
      type: 'legacy',
    }
  }

  // we only have cli config
  return {
    config: configDefinition.parse(config?.config?.typegen || {}),
    path: config?.path,
    type: 'cli',
  }
}

const formatter = new Intl.NumberFormat('en-US', {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 1,
})
const percent = (value: number): string => formatter.format(Math.min(value, 1))
const count = (
  amount: number,
  plural: string = '',
  singular: string = plural.slice(0, Math.max(0, plural.length - 1)),
): string =>
  [amount.toLocaleString('en-US'), amount === 1 ? singular : plural].filter(Boolean).join(' ')
const getMessage = (error: unknown) =>
  typeof error === 'object' && !!error && 'message' in error && typeof error.message === 'string'
    ? error.message
    : 'Unknown error'

export default async function typegenGenerateAction(
  {extOptions: flags}: CliCommandArguments<TypegenGenerateTypesCommandFlags>,
  {output, workDir, telemetry}: CliCommandContext,
): Promise<void> {
  const trace = telemetry.trace(TypesGeneratedTrace)
  trace.start()

  const spinner = output.spinner({}).start('Loading config…')

  const {
    config: typegenConfig,
    type: typegenConfigMethod,
    path: configPath,
  } = await getConfig(workDir, flags['config-path'])

  spinner.succeed(`Config loaded from ${configPath?.replace(workDir, '.')}`)

  const {
    generates,
    path: searchPath,
    schema: schemaPath,
    formatGeneratedCode,
    overloadClientMethods,
  } = typegenConfig

  const outputPath = isAbsolute(typegenConfig.generates)
    ? typegenConfig.generates
    : join(workDir, typegenConfig.generates)

  const outputDir = dirname(outputPath)
  await mkdir(outputDir, {recursive: true})

  const workerPath = await getCliWorkerPath('typegenGenerate')
  const workerData: TypegenGenerateTypesWorkerData = {
    workDir,
    schemaPath,
    searchPath,
    overloadClientMethods,
  }
  const worker = new Worker(workerPath, {workerData, env})
  const receiver = WorkerChannelReceiver.from<TypegenWorkerChannel>(worker)

  try {
    spinner.start(`Loading schema…`)
    await receiver.event.loadedSchema()
    spinner.succeed(`Schema loaded from ${schemaPath}`)

    spinner.start('Generating schema types…')
    const {expectedFileCount} = await receiver.event.typegenStarted()
    const {schemaTypeDeclarations} = await receiver.event.generatedSchemaTypes()
    const schemaTypesCount = schemaTypeDeclarations.length
    spinner.succeed(`Generated ${count(schemaTypesCount, 'schema types')}`)

    spinner.start('Generating query types…')
    let queriesCount = 0
    let evaluatedFiles = 0
    let filesWithErrors = 0
    let queryFilesCount = 0
    let typeNodesGenerated = 0
    let unknownTypeNodesGenerated = 0
    let emptyUnionTypeNodesGenerated = 0

    for await (const {queries, errors} of receiver.stream.evaluatedModules()) {
      evaluatedFiles++
      queriesCount += queries.length
      queryFilesCount += queries.length ? 1 : 0
      filesWithErrors += errors.length ? 1 : 0

      for (const {stats} of queries) {
        typeNodesGenerated += stats.allTypes
        unknownTypeNodesGenerated += stats.unknownTypes
        emptyUnionTypeNodesGenerated += stats.emptyUnions
      }

      for (const error of errors) {
        spinner.fail(getMessage(error))
      }

      spinner.text =
        `Generating query types… (${percent(evaluatedFiles / expectedFileCount)})\n` +
        `  └─ Processed ${count(evaluatedFiles)} of ${count(expectedFileCount, 'files')}. ` +
        `Found ${count(queriesCount, 'queries', 'query')} from ${count(queryFilesCount, 'files')}.`
    }

    const result = await receiver.event.typegenComplete()
    const code = `${generatedFileWarning}${result.code}`
    await writeFile(outputPath, code)

    spinner.succeed(
      `Generated ${count(queriesCount, 'query types')} from ${count(queryFilesCount, 'files')} out of ${count(evaluatedFiles, 'scanned files')}`,
    )

    if (formatGeneratedCode) {
      spinner.start(`Formatting generated types with prettier…`)

      try {
        const prettier = await import('prettier')
        const prettierConfig = await prettier.resolveConfig(outputPath)
        const formattedCode = await prettier.format(code, {
          ...prettierConfig,
          parser: 'typescript' as const,
        })
        await writeFile(outputPath, formattedCode)

        spinner.succeed('Formatted generated types with prettier')
      } catch (err) {
        spinner.warn(`Failed to format generated types with prettier: ${getMessage(err)}`)
      }
    }

    trace.log({
      configOverloadClientMethods: overloadClientMethods,
      outputSize: Buffer.byteLength(result.code),
      queriesCount,
      schemaTypesCount,
      queryFilesCount,
      filesWithErrors,
      typeNodesGenerated,
      unknownTypeNodesGenerated,
      emptyUnionTypeNodesGenerated,
      unknownTypeNodesRatio:
        typeNodesGenerated > 0 ? unknownTypeNodesGenerated / typeNodesGenerated : 0,
      configMethod: typegenConfigMethod,
    })

    if (filesWithErrors > 0) {
      spinner.warn(
        `Encountered errors in ${count(filesWithErrors, 'files')} while generating types`,
      )
    }

    spinner.succeed(`Successfully generated types to ${generates}`)
  } catch (err) {
    trace.error(err)
    throw err
  } finally {
    receiver.unsubscribe()
    trace.complete()
    await worker.terminate()
  }
}
