/* eslint-disable max-statements */
import {mkdir, writeFile} from 'node:fs/promises'
import {dirname, join} from 'node:path'
import {env} from 'node:process'
import {Worker} from 'node:worker_threads'

import {readConfig} from '@sanity/codegen'
import {WorkerChannelReceiver} from '@sanity/worker-channels'

import {type CliCommandArguments, type CliCommandContext} from '../../types'
import {getCliWorkerPath} from '../../util/cliWorker'
import {
  type TypegenGenerateTypesWorkerData,
  type TypegenWorkerChannel,
} from '../../workers/typegenGenerate'
import {TypesGeneratedTrace} from './generate.telemetry'

export interface TypegenGenerateTypesCommandFlags {
  'config-path'?: string
}

const generatedFileWarning = `/**
 * ---------------------------------------------------------------------------------
 * This file has been generated by Sanity TypeGen.
 * Command: \`sanity typegen generate\`
 *
 * Any modifications made directly to this file will be overwritten the next time
 * the TypeScript definitions are generated. Please make changes to the Sanity
 * schema definitions and/or GROQ queries if you need to update these types.
 *
 * For more information on how to use Sanity TypeGen, visit the official documentation:
 * https://www.sanity.io/docs/sanity-typegen
 * ---------------------------------------------------------------------------------
 */\n\n`

const formatter = new Intl.NumberFormat('en-US', {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 1,
})
const percent = (value: number): string => formatter.format(Math.min(value, 1))
const count = (
  amount: number,
  plural: string = '',
  singular: string = plural.slice(0, Math.max(0, plural.length - 1)),
): string =>
  [amount.toLocaleString('en-US'), amount === 1 ? singular : plural].filter(Boolean).join(' ')
const getMessage = (error: unknown) =>
  typeof error === 'object' && !!error && 'message' in error && typeof error.message === 'string'
    ? error.message
    : 'Unknown error'

export default async function typegenGenerateAction(
  {extOptions: flags}: CliCommandArguments<TypegenGenerateTypesCommandFlags>,
  {output, workDir, telemetry}: CliCommandContext,
): Promise<void> {
  const trace = telemetry.trace(TypesGeneratedTrace)
  trace.start()

  const spinner = output.spinner({}).start('Generating types…')

  const {
    generates,
    path: searchPath,
    schema: schemaPath,
    formatGeneratedCode,
    overloadClientMethods,
    augmentGroqModule,
  } = await readConfig(flags['config-path'] || 'sanity-typegen.json')

  const outputPath = join(workDir, generates)
  const outputDir = dirname(outputPath)
  await mkdir(outputDir, {recursive: true})

  const workerPath = await getCliWorkerPath('typegenGenerate')
  const workerData: TypegenGenerateTypesWorkerData = {
    workDir,
    schemaPath,
    searchPath,
    overloadClientMethods,
    augmentGroqModule,
  }
  const worker = new Worker(workerPath, {workerData, env})
  const receiver = WorkerChannelReceiver.from<TypegenWorkerChannel>(worker)

  try {
    spinner.start(`Loading schema…`)

    await receiver.event.loadedSchema()
    spinner.succeed(`Loaded schema from ${schemaPath}`)

    spinner.start('Generating schema types…')
    const {expectedFileCount} = await receiver.event.typegenStarted()
    const {schemaTypeDeclarations} = await receiver.event.generatedSchemaTypes()
    const schemaTypesCount = schemaTypeDeclarations.length
    spinner.succeed(`Generated ${count(schemaTypesCount, 'schema types')}`)

    spinner.start('Generating query types…')
    let queriesCount = 0
    let evaluatedFiles = 0
    let filesWithErrors = 0
    let queryFilesCount = 0
    let typeNodesGenerated = 0
    let unknownTypeNodesGenerated = 0
    let emptyUnionTypeNodesGenerated = 0

    for await (const {queries, errors} of receiver.stream.evaluatedModules()) {
      evaluatedFiles++
      queriesCount += queries.length
      queryFilesCount += queries.length ? 1 : 0
      filesWithErrors += errors.length ? 1 : 0

      for (const {stats} of queries) {
        typeNodesGenerated += stats.allTypes
        unknownTypeNodesGenerated += stats.unknownTypes
        emptyUnionTypeNodesGenerated += stats.emptyUnions
      }

      for (const error of errors) {
        spinner.fail(getMessage(error))
      }

      spinner.text =
        `Generating query types… (${percent(evaluatedFiles / expectedFileCount)})\n` +
        `  └─ Processed ${count(evaluatedFiles)} of ${count(expectedFileCount, 'files')}. ` +
        `Found ${count(queriesCount, 'queries', 'query')} from ${count(queryFilesCount, 'files')}.`
    }

    const result = await receiver.event.typegenComplete()
    const code = `${generatedFileWarning}${result.code}`
    await writeFile(outputPath, code)

    spinner.succeed(
      `Generated ${count(queriesCount, 'query types')} from ${count(queryFilesCount, 'files')} out of ${count(evaluatedFiles, 'scanned files')}`,
    )

    if (formatGeneratedCode) {
      spinner.start(`Formatting generated types with prettier…`)

      try {
        const prettier = await import('prettier')
        const prettierConfig = await prettier.resolveConfig(outputPath)
        const formattedCode = await prettier.format(code, {
          ...prettierConfig,
          parser: 'typescript' as const,
        })
        await writeFile(outputPath, formattedCode)

        spinner.succeed('Formatted generated types with prettier')
      } catch (err) {
        spinner.warn(`Failed to format generated types with prettier: ${getMessage(err)}`)
      }
    }

    trace.log({
      configOverloadClientMethods: overloadClientMethods,
      configAugmentGroqModule: augmentGroqModule,
      outputSize: Buffer.byteLength(result.code),
      queriesCount,
      schemaTypesCount,
      queryFilesCount,
      filesWithErrors,
      typeNodesGenerated,
      unknownTypeNodesGenerated,
      emptyUnionTypeNodesGenerated,
      unknownTypeNodesRatio:
        typeNodesGenerated > 0 ? unknownTypeNodesGenerated / typeNodesGenerated : 0,
    })

    if (filesWithErrors > 0) {
      spinner.warn(
        `Encountered errors in ${count(filesWithErrors, 'files')} while generating types`,
      )
    }

    spinner.succeed(`Successfully generated types to ${generates}`)
  } catch (err) {
    trace.error(err)
    throw err
  } finally {
    receiver.unsubscribe()
    trace.complete()
    await worker.terminate()
  }
}
