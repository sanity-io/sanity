/* eslint-disable max-nested-callbacks */
import {CodeGenerator} from '@babel/generator'
import * as t from '@babel/types'
import {type SchemaType} from 'groq-js'

import {AsyncQueue} from './asyncQueue'
import {type NamedQueryResult} from './expressionResolvers'
import {type QueryExtractionResult} from './findQueriesInPath'
import {SchemaTypeGenerator, type TypeEvaluationStats} from './schemaTypeGenerator'

const SanityQueries = t.identifier('SanityQueries')
const SanityProjections = t.identifier('SanityProjections')
const SanitySchemas = t.identifier('SanitySchemas')
const SchemaOrigin = t.identifier('SchemaOrigin')
const PickSchema = t.identifier('PickSchema')
const AllSanitySchemaTypes = t.identifier('AllSanitySchemaTypes')

export interface QueryResultDeclaration {
  filename: string
  name: string
  id: t.Identifier
  query: string
  code: string
  type: 'query' | 'projection'
  stats: TypeEvaluationStats
}

export type QueryResultDeclarationsFileResult =
  | {
      type: 'queries'
      filename: string
      queryResultDeclarations: QueryResultDeclaration[]
    }
  | {
      type: 'error'
      filename: string
      error: unknown
    }

/**
 * @internal
 */
export interface TypeGeneratorOptions {
  schemas: {schema: SchemaType; schemaId: string; filename?: string}[]
  queriesByFile?: AsyncIterable<QueryExtractionResult>
  augmentGroqModule?: boolean
  overloadClientMethods?: boolean
}

/**
 * @internal
 */
export class TypeGenerator {
  public readonly schemas: SchemaTypeGenerator[]
  public readonly augmentGroqModule: boolean
  public readonly overloadClientMethods: boolean

  private schemaFilenames = new Map<string, string>()
  private globalIdentifiers = new Set<string>()
  private identifiersByQuery = new Map<string, t.Identifier[]>()
  private identifiersByProjection = new Map<string, t.Identifier[]>()
  private queryResultsQueue = new AsyncQueue<QueryResultDeclarationsFileResult>()
  private augmentedQueryResultsPromise = promiseWithResolvers<{code: string}>()
  private queryFileCountPromise = promiseWithResolvers<{fileCount: number}>()

  constructor({
    schemas,
    queriesByFile,
    augmentGroqModule = true,
    overloadClientMethods = true,
  }: TypeGeneratorOptions) {
    this.globalIdentifiers.add(SanityQueries.name)
    this.globalIdentifiers.add(SanityProjections.name)
    this.globalIdentifiers.add(SanitySchemas.name)
    this.globalIdentifiers.add(SchemaOrigin.name)
    this.globalIdentifiers.add(PickSchema.name)
    this.globalIdentifiers.add(AllSanitySchemaTypes.name)
    this.globalIdentifiers.add(SchemaTypeGenerator.InternalReferenceSymbol.name)
    this.globalIdentifiers.add(SchemaTypeGenerator.ProjectionBase.name)

    const schemaIds = new Set<string>()
    for (const {schemaId, filename} of schemas) {
      if (schemaIds.has(schemaId)) {
        throw new Error(`Duplicate schema ID "${schemaId}". Schema IDs must be unique.`)
      }
      schemaIds.add(schemaId)
      if (filename) {
        this.schemaFilenames.set(schemaId, filename)
      }
    }

    this.schemas = schemas.map((opts) => new SchemaTypeGenerator(opts))
    this.augmentGroqModule = augmentGroqModule
    this.overloadClientMethods = overloadClientMethods

    // We need to eagerly compute these in the constructor because
    // `generateAndRegisterExportedTypeAlias` has a side effect of reserving
    // global identifier names. The order also matters as `getSchemaDeclarations`
    // depends on the identifiers generated by `getSchemaTypeDeclarations`.
    this.getSchemaTypeDeclarations()
    this.getSchemaDeclarations()

    if (queriesByFile) {
      this.handleQueries(queriesByFile).catch((error) => {
        this.queryFileCountPromise.reject(error)
        this.queryResultsQueue.throwError(error)
        this.augmentedQueryResultsPromise.reject(error)
      })
    } else {
      this.queryFileCountPromise.resolve({fileCount: 0})
    }
  }

  private async handleQueries(queriesByFile: AsyncIterable<QueryExtractionResult>) {
    for await (const result of queriesByFile) {
      if (result.type === 'files') {
        this.queryFileCountPromise.resolve({fileCount: result.fileCount})
        continue
      }

      try {
        if (result.type === 'error') throw result.error
        const {filename, queries} = result

        const queryResultDeclarations: QueryResultDeclaration[] = []
        for (const query of queries) {
          try {
            queryResultDeclarations.push({
              filename,
              query: query.result,
              ...this.generateQueryResultType({...query, filename}),
            })
          } catch (error) {
            this.queryResultsQueue.enqueue({type: 'error', filename, error})
          }
        }

        this.queryResultsQueue.enqueue({type: 'queries', filename, queryResultDeclarations})
      } catch (error) {
        this.queryResultsQueue.enqueue({type: 'error', filename: result.filename, error})
      }
    }

    this.queryResultsQueue.finish()

    let augmentedQueryResultsCode = ''
    const clientModuleBlockStatement: t.Statement[] = []
    const groqModuleBlockStatement: t.Statement[] = []

    // Only generate SanityQueries if there are query results
    if (this.identifiersByQuery.size > 0) {
      const sanityQueriesInterfaceDeclaration = t.tsInterfaceDeclaration(
        SanityQueries,
        null,
        [],
        t.tsInterfaceBody(
          Array.from(this.identifiersByQuery).map(([query, identifiers]) =>
            t.tsPropertySignature(
              t.stringLiteral(query),
              t.tsTypeAnnotation(
                identifiers.length === 1
                  ? t.tsTypeReference(identifiers[0])
                  : t.tsUnionType(identifiers.map((i) => t.tsTypeReference(i))),
              ),
            ),
          ),
        ),
      )
      // Add to both module declarations if needed
      clientModuleBlockStatement.push(sanityQueriesInterfaceDeclaration)
      groqModuleBlockStatement.push(sanityQueriesInterfaceDeclaration)
    }

    // Only generate SanityProjections if there are projection results
    if (this.identifiersByProjection.size > 0) {
      const sanityProjectionsInterfaceDeclaration = t.tsInterfaceDeclaration(
        SanityProjections,
        null,
        [],
        t.tsInterfaceBody(
          Array.from(this.identifiersByProjection).map(([projection, identifiers]) =>
            t.tsPropertySignature(
              t.stringLiteral(projection),
              t.tsTypeAnnotation(
                identifiers.length === 1
                  ? t.tsTypeReference(identifiers[0])
                  : t.tsUnionType(identifiers.map((i) => t.tsTypeReference(i))),
              ),
            ),
          ),
        ),
      )

      // Add only to groq module declaration
      groqModuleBlockStatement.push(sanityProjectionsInterfaceDeclaration)
    }

    if (this.overloadClientMethods && clientModuleBlockStatement.length > 0) {
      const clientModuleDeclaration = t.declareModule(
        t.stringLiteral('@sanity/client'),
        t.blockStatement(clientModuleBlockStatement),
      )
      augmentedQueryResultsCode += generateCode(clientModuleDeclaration)
    }

    if (this.augmentGroqModule && groqModuleBlockStatement.length > 0) {
      const groqModuleDeclaration = t.declareModule(
        t.stringLiteral('groq'),
        t.blockStatement(groqModuleBlockStatement),
      )
      augmentedQueryResultsCode += generateCode(groqModuleDeclaration)
    }

    this.augmentedQueryResultsPromise.resolve({code: augmentedQueryResultsCode})
  }

  private generateQueryResultType({
    name,
    result,
    type,
    filename,
  }: NamedQueryResult & {filename: string}) {
    const evaluationResults: {schemaId: string; tsType: t.TSType; stats: TypeEvaluationStats}[] = []
    for (const schema of this.schemas) {
      const {schemaId} = schema

      if (type === 'projection') {
        const projectionResult = schema.evaluateProjection(result)
        if (!projectionResult) continue
        evaluationResults.push({schemaId, ...projectionResult})
      } else {
        const queryResult = schema.evaluateQuery(result)
        evaluationResults.push({schemaId, ...queryResult})
      }
    }

    const tsTypes = evaluationResults.map(({tsType, schemaId}) => {
      if (this.schemas.length === 1) return tsType
      return addSchemaOrigin(tsType, schemaId)
    })

    const tsType = tsTypes.length === 1 ? tsTypes[0] : t.tsUnionType(tsTypes)

    const {code, id} = this.generateAndRegisterExportedTypeAlias(
      `${name}${type === 'projection' ? 'ProjectionResult' : 'Result'}`,
      tsType,
      [
        {type: 'CommentLine', value: ` Source: ${filename}`},
        {type: 'CommentLine', value: ` Variable: ${name}`},
        {
          type: 'CommentLine',
          value: ` ${type === 'projection' ? 'Projection' : 'Query'}: ${result.replace(/(\r\n|\n|\r)/gm, '').trim()}`,
        },
      ],
    )

    const identifiersByProjectionOrQuery =
      type === 'projection' ? this.identifiersByProjection : this.identifiersByQuery

    let identifiers = identifiersByProjectionOrQuery.get(result)

    if (!identifiers) {
      identifiers = []
      identifiersByProjectionOrQuery.set(result, identifiers)
    }
    identifiers.push(id)

    return {
      code,
      id,
      name,
      type,
      stats: evaluationResults.reduce<TypeEvaluationStats>(
        (acc, {stats}) => ({
          allTypes: acc.allTypes + stats.allTypes,
          unknownTypes: acc.unknownTypes + stats.unknownTypes,
          emptyUnions: acc.emptyUnions + stats.emptyUnions,
        }),
        {allTypes: 0, unknownTypes: 0, emptyUnions: 0},
      ),
    }
  }

  private generateAndRegisterExportedTypeAlias(
    name: string,
    tsType: t.TSType,
    comments?: t.Comment[],
  ): {code: string; id: t.Identifier} {
    const desiredName = SchemaTypeGenerator.normalizeIdentifier(name)

    let resultingName = desiredName
    let index = 2
    while (this.globalIdentifiers.has(resultingName)) {
      resultingName = `${desiredName}_${index}`
      index++
    }

    this.globalIdentifiers.add(resultingName)

    const id = t.identifier(resultingName)

    const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType)
    let exportDeclaration = t.exportNamedDeclaration(typeAlias)

    if (comments) {
      exportDeclaration = t.addComments(exportDeclaration, 'leading', comments)
    }

    const code = generateCode(exportDeclaration)

    return {id, code}
  }

  getKnownTypes = computeOnce(() => {
    let code = ''

    if (this.overloadClientMethods) {
      code += generateCode(t.importDeclaration([], t.stringLiteral('@sanity/client')))
    }

    const importSpecifiers = [
      t.importSpecifier(SchemaTypeGenerator.ProjectionBase, SchemaTypeGenerator.ProjectionBase),
    ]

    if (this.schemas.length > 1) {
      importSpecifiers.push(t.importSpecifier(PickSchema, PickSchema))
      importSpecifiers.push(t.importSpecifier(SchemaOrigin, SchemaOrigin))
    }

    code += generateCode(
      Object.assign(t.importDeclaration(importSpecifiers, t.stringLiteral('groq')), {
        importKind: 'type',
      }),
    )

    code += generateCode(
      t.exportNamedDeclaration(
        Object.assign(
          t.variableDeclaration('const', [
            t.variableDeclarator(SchemaTypeGenerator.InternalReferenceSymbol),
          ]),
          {declare: true},
        ),
      ),
    )

    return {code}
  })

  getSchemaTypeDeclarations = computeOnce(() => {
    const typeNames = new Set(this.schemas.flatMap((schema) => schema.getTypeNames()))

    return Array.from(typeNames).flatMap((typeName) => {
      const identifiers = new Set(
        this.schemas
          .map((schema) => schema.getIdentifier(typeName)?.name)
          .filter((i) => typeof i === 'string'),
      )

      return Array.from(identifiers).map((identifier) => {
        const types = this.schemas
          .filter(
            (schema) =>
              schema.getIdentifier(typeName)?.name === identifier && !!schema.getTsType(typeName),
          )
          .map((schema) => {
            const tsType = schema.getTsType(typeName)!
            const schemaId = schema.schemaId

            // no need to wrap with SchemaOrigin if there aren't at least 2 schemas
            if (this.schemas.length < 2) return {schemaId, tsType}
            return {schemaId, tsType: addSchemaOrigin(tsType, schemaId)}
          })

        const schemaIds = types.map((i) => i.schemaId)
        const tsType =
          types.length === 1 ? types[0].tsType : t.tsUnionType(types.map((i) => i.tsType))
        const {id, code} = this.generateAndRegisterExportedTypeAlias(identifier, tsType)

        return {id, code, schemaIds}
      })
    })
  })

  getAllSanitySchemaTypesDeclaration = computeOnce(() => {
    const schemaTypeDeclarations = this.getSchemaTypeDeclarations()
    const code = generateCode(
      t.exportNamedDeclaration(
        t.tsTypeAliasDeclaration(
          AllSanitySchemaTypes,
          null,
          t.tsUnionType(schemaTypeDeclarations.map(({id}) => t.tsTypeReference(id))),
        ),
      ),
    )
    return {code}
  })

  getSchemaDeclarations = computeOnce(() => {
    const schemaTypeDeclarations = this.getSchemaTypeDeclarations()
    const identifierUsageCountBySchemaId = schemaTypeDeclarations.reduce<{
      [schemaId: string]: {[identifier: string]: number}
    }>((acc, {schemaIds, id}) => {
      for (const schemaId of schemaIds) {
        acc[schemaId] = acc[schemaId] ?? {}
        acc[schemaId][id.name] = schemaIds.length
      }
      return acc
    }, {})

    return this.schemas.map(({schemaId}) => {
      const tsTypes = Object.entries(identifierUsageCountBySchemaId[schemaId]).map(
        ([identifierName, schemaCount]) => {
          const schemaTypeReferencer = t.tsTypeReference(t.identifier(identifierName))
          if (schemaCount > 1) return addPickSchema(schemaTypeReferencer, schemaId)
          return schemaTypeReferencer
        },
      )
      const tsType = tsTypes.length === 1 ? tsTypes[0] : t.tsUnionType(tsTypes)

      const comments: t.Comment[] = []

      const filename = this.schemaFilenames.get(schemaId)
      if (filename) {
        comments.push({type: 'CommentLine', value: ` Source: ${filename}`})
      }
      comments.push({type: 'CommentLine', value: ` Schema ID: ${schemaId}`})

      const {id, code} = this.generateAndRegisterExportedTypeAlias(
        `${schemaId}Schema`,
        tsType,
        comments,
      )

      return {id, code, schemaId}
    })
  })

  getAugmentedSchemasDeclarations = computeOnce(() => {
    if (!this.augmentGroqModule) return {code: ''}
    const schemaDeclarations = this.getSchemaDeclarations()

    const groqModuleDeclaration = t.declareModule(
      t.stringLiteral('groq'),
      t.blockStatement([
        t.tsInterfaceDeclaration(
          SanitySchemas,
          null,
          [],
          t.tsInterfaceBody(
            schemaDeclarations.map(({id, schemaId}) =>
              t.tsPropertySignature(
                t.stringLiteral(schemaId),
                t.tsTypeAnnotation(t.tsTypeReference(id)),
              ),
            ),
          ),
        ),
      ]),
    )

    return {code: generateCode(groqModuleDeclaration)}
  })

  getQueryFileCount = (): Promise<{fileCount: number}> => this.queryFileCountPromise.promise

  getQueryResultDeclarations = (): AsyncIterable<QueryResultDeclarationsFileResult> =>
    this.queryResultsQueue

  getAugmentedQueryResultsDeclarations = (): Promise<{code: string}> =>
    this.augmentedQueryResultsPromise.promise
}

function computeOnce<TThis, TReturn>(this: TThis, fn: () => TReturn): (this: TThis) => TReturn {
  const ref = {current: undefined as TReturn | undefined, computed: false}

  return function (this: TThis) {
    if (ref.computed) return ref.current as TReturn
    ref.current = fn.call(this)
    ref.computed = true
    return ref.current
  }
}

function addSchemaOrigin(tsType: t.TSType, schemaId: string) {
  return t.tsTypeReference(
    SchemaOrigin,
    t.tsTypeParameterInstantiation([tsType, t.tsLiteralType(t.stringLiteral(schemaId))]),
  )
}

function addPickSchema(tsType: t.TSType, schemaId: string) {
  return t.tsTypeReference(
    PickSchema,
    t.tsTypeParameterInstantiation([tsType, t.tsLiteralType(t.stringLiteral(schemaId))]),
  )
}

function generateCode(node: t.Node) {
  return `${new CodeGenerator(node).generate().code.trim()}\n\n`
}

// Similar to `Promise.withResolvers`
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers
function promiseWithResolvers<T = void>() {
  let resolve!: (t: T) => void
  let reject!: (error: unknown) => void
  const promise = new Promise<T>((thisResolve, thisReject) => {
    resolve = thisResolve
    reject = thisReject
  })
  return {promise, resolve, reject}
}
