{"version":3,"file":"index.js","sources":["../../src/uint8arrays/index.ts","../../src/fs-webstream/peekInto.ts","../../src/fs-webstream/maybeDecompress.ts","../../src/tar-webstream/BufferList.ts","../../src/tar-webstream/headers.ts","../../src/tar-webstream/untar.ts","../../src/utils/streamToAsyncIterator.ts","../../src/debug.ts","../../src/fs-webstream/readFileAsWebStream.ts","../../src/sources/fromExportArchive.ts","../../src/fetch-utils/fetchStream.ts","../../src/fetch-utils/sanityRequestOptions.ts","../../src/fetch-utils/endpoints.ts","../../src/sources/fromExportEndpoint.ts","../../src/sources/fromDocuments.ts","../../src/defineMigration.ts","../../src/it-utils/decodeText.ts","../../src/it-utils/delay.ts","../../src/it-utils/json.ts","../../src/it-utils/filter.ts","../../src/it-utils/map.ts","../../src/it-utils/split.ts","../../src/it-utils/ndjson.ts","../../src/it-utils/take.ts","../../src/it-utils/toArray.ts","../../src/it-utils/tap.ts","../../src/it-utils/mapAsync.ts","../../src/it-utils/lastValueFrom.ts","../../src/it-utils/concatStr.ts","../../src/fs-webstream/bufferThroughFile.ts","../../src/utils/asyncIterableToStream.ts","../../src/mutations/asserters.ts","../../src/runner/utils/toSanityMutations.ts","../../src/runner/constants.ts","../../src/runner/utils/batchMutations.ts","../../src/mutations/creators.ts","../../src/mutations/operations/creators.ts","../../src/mutations/transaction.ts","../../src/runner/utils/getValueType.ts","../../src/runner/utils/flatMapDeep.ts","../../src/runner/normalizeMigrateDefinition.ts","../../src/runner/collectMigrationMutations.ts","../../src/runner/utils/getBufferFile.ts","../../src/runner/utils/createFilteredDocumentsClient.ts","../../src/runner/utils/applyFilters.ts","../../src/runner/utils/client-concurrency-limiter/ConcurrencyLimiter.ts","../../src/runner/utils/client-concurrency-limiter/createClientConcurrencyLimiter.ts","../../src/runner/utils/limitClientConcurrency.ts","../../src/runner/utils/createContextClient.ts","../../src/runner/run.ts","../../src/runner/runFromArchive.ts","../../src/runner/dryRun.ts"],"sourcesContent":["/**\n * Copied over from uint8array-extras to sort out ESM build issues. Should be replaced with imports from that module eventually\n */\nconst objectToString = Object.prototype.toString\nconst uint8ArrayStringified = '[object Uint8Array]'\n\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  if (!value) {\n    return false\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true\n  }\n\n  return objectToString.call(value) === uint8ArrayStringified\n}\n\nexport function assertUint8Array(value: unknown): asserts value is Uint8Array {\n  if (!isUint8Array(value)) {\n    throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``)\n  }\n}\n\nexport function concatUint8Arrays(arrays: Uint8Array[], totalLength?: number) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  totalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0)\n\n  const returnValue = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const array of arrays) {\n    assertUint8Array(array)\n    returnValue.set(array, offset)\n    offset += array.length\n  }\n\n  return returnValue\n}\n\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array) {\n  assertUint8Array(a)\n  assertUint8Array(b)\n\n  if (a === b) {\n    return true\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false\n    }\n  }\n\n  return true\n}\n","import {concatUint8Arrays} from '../uint8arrays'\n\nexport function peekInto(readable: ReadableStream, options: {size: number}) {\n  const {size} = options\n  return new Promise<[head: Uint8Array, ReadableStream]>((resolve, reject) => {\n    let totalBytesRead = 0\n    let streamCompleted = false\n    const chunks: Array<Uint8Array> = []\n    const reader = readable.getReader()\n\n    function settled() {\n      const head = concatUint8Arrays(chunks)\n      resolve([\n        head,\n        new ReadableStream<Uint8Array>({\n          start(controller) {\n            controller.enqueue(head)\n            if (streamCompleted) {\n              controller.close()\n            }\n          },\n          async pull(controller) {\n            const {done, value} = await reader.read()\n            if (done) {\n              controller.close()\n            } else {\n              controller.enqueue(value)\n            }\n          },\n        }),\n      ])\n    }\n    ;(async () => {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const {done, value: chunk} = await reader.read()\n        if (done) {\n          streamCompleted = true\n          break\n        } else {\n          totalBytesRead += chunk.byteLength\n          chunks.push(chunk)\n          if (totalBytesRead >= size) {\n            break\n          }\n        }\n      }\n    })().then(settled, reject)\n  })\n}\n","import {peekInto} from './peekInto'\n\nfunction isGzip(buffer: Uint8Array) {\n  return buffer.length > 3 && buffer[0] === 0x1f && buffer[1] === 0x8b && buffer[2] === 0x08\n}\n\nfunction isDeflate(buf: Uint8Array) {\n  return buf.length > 2 && buf[0] === 0x78 && (buf[1] === 1 || buf[1] === 0x9c || buf[1] === 0xda)\n}\n\nexport async function maybeDecompress(readable: ReadableStream<Uint8Array>) {\n  const [head, stream] = await peekInto(readable, {size: 10})\n  if (isGzip(head)) {\n    return stream.pipeThrough(new DecompressionStream('gzip'))\n  }\n  if (isDeflate(head)) {\n    return stream.pipeThrough(new DecompressionStream('deflate-raw'))\n  }\n  return stream\n}\n","import FIFO from 'fast-fifo'\nimport {concatUint8Arrays} from '../uint8arrays'\n\nconst EMPTY = new Uint8Array()\n\n// Extracted from https://github.com/mafintosh/tar-stream/blob/master/extract.js#L8 and converted to ts\nexport class BufferList {\n  public buffered: number\n  public shifted: number\n  private queue: FIFO<Uint8Array>\n  private _offset: number\n\n  constructor() {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push(buffer: Uint8Array) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst(size: number) {\n    return this.buffered === 0 ? null : this._next(size)\n  }\n\n  shift(size: number) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return concatUint8Arrays(chunks)\n  }\n\n  private _next(size: number) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n","/* eslint-disable no-bitwise */\n// Extracted from https://github.com/mafintosh/tar-stream/blob/master/headers.js\n// Converted to TypeScript and removed reliance on Node Buffers\n\nimport {areUint8ArraysEqual} from '../uint8arrays'\n\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = new Uint8Array([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst GNU_MAGIC = new Uint8Array([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = new Uint8Array([0x20, 0x00])\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexport type TarEntryType =\n  | 'file'\n  | 'link'\n  | 'symlink'\n  | 'directory'\n  | 'block-device'\n  | 'character-device'\n  | 'fifo'\n  | 'contiguous-file'\n\nexport interface TarHeader {\n  // type of entry. defaults to file. can be:\n  // file | link | symlink | directory | block-device\n  // character-device | fifo | contiguous-file\n  type: TarEntryType | null\n  // entry name\n  name: string\n  // entry size. defaults to 0\n  size: number | null\n  // entry mode. defaults to 0o755 for dirs and 0o644 otherwise\n  mode: number | null\n  // uid of entry owner. defaults to 0\n  uid: number | null\n  // gid of entry owner. defaults to 0\n  gid: number | null\n  // last modified date for entry. defaults to now.\n  mtime: Date | null\n  // linked file name. only valid for type 'link' and 'symlink' entries\n  linkname: string | null\n  // uname of entry owner. defaults to null\n  uname: string\n  // gname of entry owner. defaults to null\n  gname: string\n  // device major version. defaults to 0\n  devmajor: number | null\n  // device minor version. defaults to 0\n  devminor: number | null\n}\n\nexport function decode(\n  buf: Uint8Array,\n  filenameEncoding: BufferEncoding,\n  allowUnknownFormat: boolean,\n): TarHeader | null {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) {\n    throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n  }\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = `${decodeStr(buf, 345, 155, filenameEncoding)}/${name}`\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else if (!allowUnknownFormat) {\n    throw new Error('Invalid tar header: unknown format.')\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    type: type as TarEntryType,\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: mtime ? new Date(1000 * mtime) : null,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n  }\n}\n\nfunction isUSTAR(buf: Uint8Array) {\n  return areUint8ArraysEqual(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU(buf: Uint8Array) {\n  return (\n    areUint8ArraysEqual(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    areUint8ArraysEqual(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n  )\n}\n\nfunction clamp(index: number, len: number, defaultValue: number) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\nfunction toType(flag: number) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n    default:\n      return null\n  }\n}\n\nfunction indexOf(block: Uint8Array, num: number, offset: number, end: number) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum(block: Uint8Array) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256(buf: Uint8Array) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xff) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xff - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nconst decoders: {[encoding: string]: TextDecoder} = {}\nconst getCachedDecoder = (encoding: string) => {\n  if (!(encoding in decoders)) {\n    decoders[encoding] = new TextDecoder(encoding)\n  }\n  return decoders[encoding]\n}\n\nfunction toString(uint8: Uint8Array, encoding = 'utf-8') {\n  return getCachedDecoder(encoding).decode(uint8)\n}\n\nfunction decodeOct(val: Uint8Array, offset: number, length: number) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  }\n  // Older versions of tar can prefix with spaces\n  while (offset < val.length && val[offset] === 32) offset++\n  const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n  while (offset < end && val[offset] === 0) offset++\n  if (end === offset) return 0\n  return parseInt(toString(val.subarray(offset, end)), 8)\n}\n\nfunction decodeStr(val: Uint8Array, offset: number, length: number, encoding?: string) {\n  return toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n","/* eslint-disable no-bitwise,callback-return */\nimport {BufferList} from './BufferList'\nimport type {TarHeader} from './headers'\nimport * as headers from './headers'\n\n// Inspired by\n// - https://github.com/alanshaw/it-tar/blob/master/src/extract.ts\n// - https://github.com/mafintosh/tar-stream/blob/master/extract.js\n\nconst emptyReadableStream = () =>\n  new ReadableStream({\n    pull(controller) {\n      controller.close()\n    },\n  })\n\nexport function untar(\n  stream: ReadableStream<Uint8Array>,\n  options: {\n    filenameEncoding?: BufferEncoding\n    allowUnknownFormat?: boolean\n  } = {},\n): ReadableStream<[header: TarHeader, entry: ReadableStream<Uint8Array>]> {\n  const buffer = new BufferList()\n\n  const reader = stream.getReader()\n\n  let readingChunk = false\n  return new ReadableStream({\n    async pull(controller) {\n      if (readingChunk) {\n        return\n      }\n      const {done, value} = await reader.read()\n\n      if (!done) {\n        buffer.push(value)\n      }\n\n      const headerChunk = buffer.shift(512)\n      if (!headerChunk) {\n        throw new Error('Unexpected end of tar file. Expected 512 bytes of headers.')\n      }\n\n      const header = headers.decode(\n        headerChunk,\n        options.filenameEncoding ?? 'utf-8',\n        options.allowUnknownFormat ?? false,\n      )\n      if (header) {\n        if (header.size === null || header.size === 0 || header.type === 'directory') {\n          controller.enqueue([header, emptyReadableStream()])\n        } else {\n          readingChunk = true\n          controller.enqueue([\n            header,\n            entryStream(reader, header.size!, buffer, () => {\n              readingChunk = false\n            }),\n          ])\n        }\n      } else if (done) {\n        // note - there might be more data in the buffer, after the input stream is done\n        // so only complete if we couldn't find a header\n        controller.close()\n      }\n    },\n  })\n}\n\nfunction entryStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  expectedBytes: number,\n  buffer: BufferList,\n  next: () => void,\n) {\n  let totalBytesRead = 0\n  // let pulling = false\n  return new ReadableStream({\n    async pull(controller) {\n      const {done, value} = await reader.read()\n      const remaining = expectedBytes - totalBytesRead\n\n      if (!done) {\n        buffer.push(value)\n      }\n\n      const chunk = buffer.shiftFirst(remaining)\n      if (!chunk) {\n        throw new Error('Premature end of tar stream')\n      }\n      controller.enqueue(chunk)\n      totalBytesRead += chunk!.byteLength\n      if (chunk?.byteLength === remaining) {\n        // We've reached the end of the entry, discard any padding at the end (\n        discardPadding(buffer, expectedBytes)\n        controller.close()\n        next()\n      }\n    },\n  })\n}\n\nfunction getPadding(size: number) {\n  size &= 511\n  return size === 0 ? 0 : 512 - size\n}\n\nfunction discardPadding(bl: BufferList, size: number) {\n  const overflow = getPadding(size)\n  if (overflow > 0) {\n    bl.shift(overflow)\n  }\n}\n","export async function* streamToAsyncIterator<T>(stream: ReadableStream<T>) {\n  // Get a lock on the stream\n  const reader = stream.getReader()\n  try {\n    while (true) {\n      // Read from the stream\n      const {done, value} = await reader.read()\n\n      // Exit if we're done\n      if (done) return\n      // Else yield the chunk\n      yield value\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n","import createDebug from 'debug'\n\nexport default createDebug('sanity:migrate')\n","import type {FileHandle} from 'node:fs/promises'\nimport {open} from 'node:fs/promises'\nimport baseDebug from '../debug'\n\nconst debug = baseDebug.extend('readFileAsWebStream')\n\nexport function readFileAsWebStream(filename: string): ReadableStream<Uint8Array> {\n  const CHUNK_SIZE = 1024\n\n  let fileHandle: FileHandle\n  let position = 0\n\n  return new ReadableStream({\n    async start() {\n      debug('Starting readable stream from', filename)\n      fileHandle = await open(filename, 'r')\n    },\n    async pull(controller) {\n      const buffer = new Uint8Array(CHUNK_SIZE)\n\n      const {bytesRead} = await fileHandle.read(buffer, 0, CHUNK_SIZE, position)\n      if (bytesRead === 0) {\n        await fileHandle.close()\n        debug('Closing readable stream from', filename)\n        controller.close()\n      } else {\n        position += bytesRead\n        controller.enqueue(buffer.subarray(0, bytesRead))\n      }\n    },\n\n    cancel() {\n      debug('Cancelling readable stream from', filename)\n      return fileHandle.close()\n    },\n  })\n}\n","import {maybeDecompress} from '../fs-webstream/maybeDecompress'\n\nimport {untar} from '../tar-webstream/untar'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {readFileAsWebStream} from '../fs-webstream/readFileAsWebStream'\n\nexport async function* fromExportArchive(path: string) {\n  for await (const [header, entry] of streamToAsyncIterator(\n    untar(await maybeDecompress(readFileAsWebStream(path))),\n  )) {\n    if (header.type === 'file' && header.name.endsWith('.ndjson')) {\n      for await (const chunk of streamToAsyncIterator(entry)) {\n        yield chunk\n      }\n    }\n  }\n}\n","import {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\n\nexport interface FetchOptions {\n  url: string | URL\n  init: RequestInit\n}\nexport interface HTTPError extends Error {\n  statusCode: number\n}\n\nexport async function assert2xx(res: Response): Promise<void> {\n  if (res.status < 200 || res.status > 299) {\n    const response = await res.json().catch(() => {\n      throw new Error(`Error parsing JSON ${res.status}: ${res.statusText}`)\n    })\n\n    const message = response.error\n      ? response.error.description\n      : `HTTP Error ${res.status}: ${res.statusText}`\n\n    const err = new Error(message) as HTTPError\n    err.statusCode = res.status\n    throw err\n  }\n}\n\nexport async function fetchStream({url, init}: FetchOptions) {\n  const response = await fetch(url, init)\n  await assert2xx(response)\n  if (response.body === null) throw new Error('No response received')\n  return response.body\n}\n\nexport async function fetchAsyncIterator(options: FetchOptions) {\n  return streamToAsyncIterator(await fetchStream(options))\n}\n","import type {FetchOptions} from './fetchStream'\nimport type {Endpoint} from './endpoints'\n\nfunction getUserAgent() {\n  if (typeof window === 'undefined') {\n    // only set UA if we're in a non-browser environment\n    try {\n      const pkg = require('../../package.json')\n      return `${pkg.name}@${pkg.version}`\n      // eslint-disable-next-line no-empty\n    } catch (err) {}\n  }\n  return null\n}\n\ninterface SanityRequestOptions {\n  endpoint: Endpoint\n  apiVersion: `vX` | `v${number}-${number}-${number}`\n  apiHost: string\n  projectId: string\n  token?: string\n  body?: string\n  tag?: string\n}\n\nfunction normalizeApiHost(apiHost: string) {\n  return apiHost.replace(/^https?:\\/\\//, '')\n}\n\nexport function toFetchOptions(req: SanityRequestOptions): FetchOptions {\n  const {endpoint, apiVersion, tag, projectId, apiHost, token, body} = req\n  const requestInit: RequestInit = {\n    method: endpoint.method || 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body,\n  }\n  const ua = getUserAgent()\n  if (ua) {\n    requestInit.headers = {\n      ...requestInit.headers,\n      'User-Agent': ua,\n    }\n  }\n  if (token) {\n    requestInit.headers = {\n      ...requestInit.headers,\n      Authorization: `bearer ${token}`,\n    }\n  }\n  const normalizedApiHost = normalizeApiHost(apiHost)\n  const path = `/${apiVersion}${endpoint.path}`\n  const host = endpoint.global ? normalizedApiHost : `${projectId}.${normalizedApiHost}`\n  const searchParams = new URLSearchParams([\n    ...endpoint.searchParams,\n    ...(tag ? [['tag', tag]] : []),\n  ]).toString()\n\n  return {\n    url: `https://${host}/${path}${searchParams ? `?${searchParams}` : ''}`,\n    init: requestInit,\n  }\n}\n","type SupportedMethod = 'GET' | 'POST'\nexport type Endpoint = {\n  global: boolean\n  path: `/${string}`\n  searchParams: [param: string, value: string][]\n  method: SupportedMethod\n}\n\nexport const endpoints = {\n  users: {\n    me: (): Endpoint => ({\n      global: true,\n      path: `/users/me`,\n      method: 'GET',\n      searchParams: [],\n    }),\n  },\n  data: {\n    query: (dataset: string): Endpoint => ({\n      global: false,\n      method: 'GET',\n      path: `/query/${dataset}`,\n      searchParams: [],\n    }),\n    export: (dataset: string, documentTypes?: string[]): Endpoint => ({\n      global: false,\n      method: 'GET',\n      path: `/data/export/${dataset}`,\n      searchParams:\n        documentTypes && documentTypes?.length > 0 ? [['types', documentTypes.join(',')]] : [],\n    }),\n    mutate: (\n      dataset: string,\n      options?: {\n        returnIds?: boolean\n        returnDocuments?: boolean\n        visiblity?: 'async' | 'sync' | 'deferred'\n        dryRun?: boolean\n        tag?: string\n      },\n    ): Endpoint => {\n      const params = [\n        options?.tag && ['tag', options.tag],\n        options?.returnIds && ['returnIds', 'true'],\n        options?.returnDocuments && ['returnDocuments', 'true'],\n        options?.visiblity && ['visibility', options.visiblity],\n        options?.dryRun && ['dryRun', 'true'],\n      ].filter(Boolean) as [string, string][]\n\n      return {\n        global: false,\n        method: 'POST',\n        path: `/data/mutate/${dataset}`,\n        searchParams: params,\n      }\n    },\n  },\n}\n","import {createSafeJsonParser} from '@sanity/util/createSafeJsonParser'\nimport {SanityDocument} from '@sanity/types'\nimport {fetchStream} from '../fetch-utils/fetchStream'\nimport {toFetchOptions} from '../fetch-utils/sanityRequestOptions'\nimport {endpoints} from '../fetch-utils/endpoints'\nimport {ExportAPIConfig} from '../types'\n\nexport function fromExportEndpoint(options: ExportAPIConfig) {\n  return fetchStream(\n    toFetchOptions({\n      projectId: options.projectId,\n      apiVersion: options.apiVersion,\n      token: options.token,\n      apiHost: options.apiHost ?? 'api.sanity.io',\n      tag: 'sanity.migration.export',\n      endpoint: endpoints.data.export(options.dataset, options.documentTypes),\n    }),\n  )\n}\n\n/**\n * Safe JSON parser that is able to handle lines interrupted by an error object.\n *\n * This may occur when streaming NDJSON from the Export HTTP API.\n *\n * @internal\n * @see {@link https://github.com/sanity-io/sanity/pull/1787 | Initial pull request}\n */\nexport const safeJsonParser = createSafeJsonParser<SanityDocument>({\n  errorLabel: 'Error streaming dataset',\n})\n","import {SanityDocument} from '@sanity/types'\n\nexport function* fromDocuments(documents: SanityDocument[]) {\n  for (const document of documents) {\n    yield document\n  }\n}\n","import type {Migration} from './types'\n\nexport function defineMigration<T extends Migration>(migration: T): T {\n  return migration\n}\n","export async function* decodeText(it: AsyncIterableIterator<Uint8Array>) {\n  const decoder = new TextDecoder()\n  for await (const chunk of it) {\n    yield decoder.decode(chunk)\n  }\n}\n","function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nexport async function* delay<T>(it: AsyncIterableIterator<T>, ms: number) {\n  for await (const chunk of it) {\n    await sleep(ms)\n    yield chunk\n  }\n}\n","export type JSONParser<Type> = (line: string) => Type\n\nexport interface JSONOptions<Type> {\n  parse?: JSONParser<Type>\n}\n\nexport async function* parseJSON<Type>(\n  it: AsyncIterableIterator<string>,\n  {parse = JSON.parse}: JSONOptions<Type> = {},\n): AsyncIterableIterator<Type> {\n  for await (const chunk of it) {\n    yield parse(chunk)\n  }\n}\n\nexport async function* stringifyJSON(it: AsyncIterableIterator<unknown>) {\n  for await (const chunk of it) {\n    yield JSON.stringify(chunk)\n  }\n}\n","export async function* filter<T>(\n  it: AsyncIterableIterator<T>,\n  predicate: (value: T) => boolean | Promise<boolean>,\n) {\n  for await (const chunk of it) {\n    if (await predicate(chunk)) {\n      yield chunk\n    }\n  }\n}\n","export async function* map<T, U>(\n  it: AsyncIterableIterator<T>,\n  project: (value: T) => U,\n): AsyncIterableIterator<U> {\n  for await (const chunk of it) {\n    yield project(chunk)\n  }\n}\n","export async function* split(\n  it: AsyncIterableIterator<string>,\n  delimiter: string,\n): AsyncIterableIterator<string> {\n  let buf = ''\n  for await (const chunk of it) {\n    buf += chunk\n    if (buf.includes(delimiter)) {\n      const lastIndex = buf.lastIndexOf(delimiter)\n      const parts = buf.substring(0, lastIndex).split(delimiter)\n\n      for (const part of parts) {\n        yield part\n      }\n      buf = buf.substring(lastIndex + delimiter.length)\n    }\n  }\n  yield buf\n}\n","import {split} from './split'\nimport {type JSONOptions, parseJSON} from './json'\nimport {filter} from './filter'\n\nexport function parse<Type>(\n  it: AsyncIterableIterator<string>,\n  options?: JSONOptions<Type>,\n): AsyncIterableIterator<Type> {\n  return parseJSON(\n    filter(split(it, '\\n'), (line) => Boolean(line && line.trim())),\n    options,\n  )\n}\n\nexport async function* stringify(iterable: AsyncIterableIterator<unknown>) {\n  for await (const doc of iterable) {\n    yield `${JSON.stringify(doc)}\\n`\n  }\n}\n","export async function* take<T>(it: AsyncIterableIterator<T>, count: number) {\n  let i = 0\n  for await (const chunk of it) {\n    if (i++ >= count) return\n    yield chunk\n  }\n}\n","export async function toArray<T>(it: AsyncIterableIterator<T>): Promise<T[]> {\n  const result: T[] = []\n  for await (const chunk of it) {\n    result.push(chunk)\n  }\n  return result\n}\n","export async function* tap<T>(it: AsyncIterableIterator<T>, interceptor: (value: T) => void) {\n  for await (const chunk of it) {\n    interceptor(chunk)\n    yield chunk\n  }\n}\n","export async function mapAsync<T, U>(\n  it: AsyncIterableIterator<T>,\n  project: (value: T) => Promise<U>,\n  concurrency: number,\n): Promise<AsyncIterable<U>> {\n  // todo: convert to top level import when we can\n  const {pMapIterable} = await import('p-map')\n\n  return pMapIterable(it, (v) => project(v), {\n    concurrency: concurrency,\n  })\n}\n","interface Options<T> {\n  defaultValue?: T\n}\nexport async function lastValueFrom<T>(\n  it: AsyncIterableIterator<T>,\n  options?: Options<T>,\n): Promise<T> {\n  const defaultGiven = 'defaultValue' in (options ?? {})\n  let latestValue: T | undefined\n  let didYield = false\n\n  for await (const value of it) {\n    didYield = true\n    latestValue = value\n  }\n  if (!didYield) {\n    if (defaultGiven) {\n      return options!.defaultValue!\n    }\n    throw new Error(\n      'No value yielded from async iterable. If this iterable is empty, provide a default value.',\n    )\n  }\n  return latestValue!\n}\n","/**\n * Concatenates each chunk of a string iterator to a buffer and yields the buffer when the input iterator is done\n * @param it - The input iterator\n */\nexport async function* concatStr(it: AsyncIterableIterator<string>): AsyncIterableIterator<string> {\n  let buf = ''\n  for await (const chunk of it) {\n    buf += chunk\n  }\n  yield buf\n}\n","import {FileHandle, open} from 'node:fs/promises'\nimport baseDebug from '../debug'\n\nconst debug = baseDebug.extend('bufferThroughFile')\n\nconst CHUNK_SIZE = 1024\n\n/**\n * Takes a source stream that will be drained and written to the provided file name as fast as possible.\n * and returns a function that can be called to create multiple readable stream on top of the buffer file.\n * It will start pulling data from the source stream once the first readableStream is created, writing to the buffer file in the background.\n * The readable streams and can be read at any rate (but will not receive data faster than the buffer file is written to).\n * Note: by default, buffering will run to completion, and this may prevent the process from exiting after done reading from the\n * buffered streams. To stop writing to the buffer file, an AbortSignal can be provided and once it's controller aborts, the buffer file will\n * stop. After the signal is aborted, no new buffered readers can be created.\n *\n * @param source - The source readable stream. Will be drained as fast as possible.\n * @param filename - The filename to write to.\n * @param options - Optional AbortSignal to stop writing to the buffer file.\n * @returns A function that can be called multiple times to create a readable stream on top of the buffer file.\n */\nexport function bufferThroughFile(\n  source: ReadableStream<Uint8Array | string>,\n  filename: string,\n  options?: {signal: AbortSignal},\n) {\n  const signal = options?.signal\n\n  let writeHandle: FileHandle\n  let readHandle: Promise<FileHandle> | null\n\n  // Whether the all data has been written to the buffer file.\n  let bufferDone = false\n\n  signal?.addEventListener('abort', async () => {\n    debug('Aborting bufferThroughFile')\n    await Promise.all([\n      writeHandle && writeHandle.close(),\n      readHandle && (await readHandle).close(),\n    ])\n  })\n\n  // Number of active readers. When this reaches 0, the read handle will be closed.\n  let readerCount = 0\n  let ready: Promise<void>\n\n  async function pump(reader: ReadableStreamDefaultReader<Uint8Array | string>) {\n    try {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const {done, value} = await reader.read()\n        if (done || signal?.aborted) {\n          // if we're done reading, or the primary reader has been cancelled, stop writing to the buffer file\n          return\n        }\n        await writeHandle.write(value)\n      }\n    } finally {\n      await writeHandle.close()\n      bufferDone = true\n      reader.releaseLock()\n    }\n  }\n\n  function createBufferedReader() {\n    let totalBytesRead = 0\n\n    return async function tryReadFromBuffer(handle: FileHandle) {\n      const {bytesRead, buffer} = await handle.read(\n        new Uint8Array(CHUNK_SIZE),\n        0,\n        CHUNK_SIZE,\n        totalBytesRead,\n      )\n      if (bytesRead === 0 && !bufferDone && !signal?.aborted) {\n        debug('Not enough data in buffer file, waiting for more data to be written')\n        // we're waiting for more data to be written to the buffer file, try again\n        return tryReadFromBuffer(handle)\n      }\n      totalBytesRead += bytesRead\n      return {bytesRead, buffer}\n    }\n  }\n\n  function init(): Promise<void> {\n    if (!ready) {\n      ready = (async () => {\n        debug('Initializing bufferThroughFile')\n        writeHandle = await open(filename, 'w')\n        // start pumping data from the source stream to the buffer file\n        // note, don't await this, as it will block the ReadableStream.start() method\n        debug('Start buffering source stream to file')\n        pump(source.getReader()).then(() => {\n          debug('Buffering source stream to buffer file')\n        })\n      })()\n    }\n    return ready\n  }\n\n  function getReadHandle(): Promise<FileHandle> {\n    if (!readHandle) {\n      debug('Opening read handle on %s', filename)\n      readHandle = open(filename, 'r')\n    }\n    return readHandle\n  }\n\n  function onReaderStart() {\n    readerCount++\n  }\n  async function onReaderEnd() {\n    readerCount--\n    if (readerCount === 0 && readHandle) {\n      const handle = readHandle\n      readHandle = null\n      debug('Closing read handle on %s', filename)\n      await (await handle).close()\n    }\n  }\n\n  return () => {\n    const readChunk = createBufferedReader()\n\n    return new ReadableStream<Uint8Array>({\n      async start() {\n        if (signal?.aborted) {\n          throw new Error('Cannot create new buffered readers on aborted stream')\n        }\n        debug('Reader started reading from file handle')\n        onReaderStart()\n        await init()\n        await getReadHandle()\n      },\n      async pull(controller) {\n        if (!readHandle) {\n          throw new Error('Cannot read from closed handle')\n        }\n        const {bytesRead, buffer} = await readChunk(await readHandle)\n        if (bytesRead === 0 && bufferDone) {\n          debug('Reader done reading from file handle')\n          await onReaderEnd()\n          controller.close()\n        } else {\n          controller.enqueue(buffer.subarray(0, bytesRead))\n        }\n      },\n    })\n  }\n}\n","export function asyncIterableToStream<T>(it: AsyncIterableIterator<T>) {\n  return new ReadableStream({\n    async pull(controller) {\n      const {value, done} = await it.next()\n      if (done) {\n        controller.close()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n","import {Mutation} from './types'\nimport {Transaction} from './transaction'\n\nexport function isMutation(mutation: unknown): mutation is Mutation {\n  return (\n    mutation !== null &&\n    typeof mutation === 'object' &&\n    'type' in mutation &&\n    (mutation.type === 'create' ||\n      mutation.type === 'createIfNotExists' ||\n      mutation.type === 'createOrReplace' ||\n      mutation.type === 'patch' ||\n      mutation.type === 'delete')\n  )\n}\n\nexport function isTransaction(mutation: unknown): mutation is Transaction {\n  return (\n    mutation !== null &&\n    typeof mutation === 'object' &&\n    'type' in mutation &&\n    mutation.type === 'transaction'\n  )\n}\n","import {Mutation as SanityMutation} from '@sanity/client'\nimport {SanityEncoder} from '@bjoerge/mutiny'\nimport arrify from 'arrify'\nimport {Mutation, Transaction} from '../../mutations'\nimport {isTransaction} from '../../mutations/asserters'\n\nexport interface TransactionPayload {\n  transactionId?: string\n  mutations: SanityMutation[]\n}\n\nexport async function* toSanityMutations(\n  it: AsyncIterableIterator<Mutation | Transaction | (Mutation | Transaction)[]>,\n): AsyncIterableIterator<SanityMutation[] | TransactionPayload> {\n  for await (const mutation of it) {\n    for (const mut of arrify(mutation)) {\n      if (isTransaction(mut)) {\n        yield {\n          transactionId: mut.id,\n          mutations: SanityEncoder.encode(mut.mutations as any) as SanityMutation[],\n        }\n        continue\n      }\n      yield SanityEncoder.encode(mutation as any[]) as SanityMutation[]\n    }\n  }\n}\n","export const MUTATION_ENDPOINT_MAX_BODY_SIZE = 1024 * 256 // 256KB\nexport const DEFAULT_MUTATION_CONCURRENCY = 6\nexport const MAX_MUTATION_CONCURRENCY = 10\n","import {Mutation as SanityMutation} from '@sanity/client'\nimport arrify from 'arrify'\nimport {TransactionPayload} from './toSanityMutations'\n\n// We're working on \"raw\" mutations, e.g what will be put into the mutations array in the request body\nconst PADDING_SIZE = '{\"mutations\":[]}'.length\n\nfunction isTransactionPayload(payload: any): payload is TransactionPayload {\n  return payload && payload.mutations && Array.isArray(payload.mutations)\n}\n\n/**\n *\n * @param mutations - Async iterable of either single values or arrays of values\n * @param maxBatchSize - Max batch size in bytes\n * Todo: add support for transaction ids too\n */\nexport async function* batchMutations(\n  mutations: AsyncIterableIterator<TransactionPayload | SanityMutation | SanityMutation[]>,\n  maxBatchSize: number,\n): AsyncIterableIterator<TransactionPayload> {\n  let currentBatch: SanityMutation[] = []\n  let currentBatchSize = 0\n\n  for await (const mutation of mutations) {\n    if (isTransactionPayload(mutation)) {\n      yield {mutations: currentBatch}\n      yield mutation\n      currentBatch = []\n      currentBatchSize = 0\n      continue\n    }\n\n    // the mutation itself may exceed the payload size, need to handle that\n    const mutationSize = JSON.stringify(mutation).length\n\n    if (mutationSize >= maxBatchSize + PADDING_SIZE) {\n      // the mutation size itself is bigger than max batch size, yield it as a single batch and hope for the best (the server has a bigger limit)\n      if (currentBatch.length) {\n        yield {mutations: currentBatch}\n      }\n      yield {mutations: [...arrify(mutation)]}\n      currentBatch = []\n      currentBatchSize = 0\n      continue\n    }\n    currentBatchSize += mutationSize\n    if (currentBatchSize >= maxBatchSize + PADDING_SIZE) {\n      yield {mutations: currentBatch}\n      currentBatch = []\n      currentBatchSize = 0\n    }\n    currentBatch.push(...arrify(mutation))\n  }\n\n  if (currentBatch.length > 0) {\n    yield {mutations: currentBatch}\n  }\n}\n","import type {Path} from '@sanity/types'\nimport arrify from 'arrify'\n\nimport {fromString} from '@sanity/util/paths'\nimport {type Operation} from './operations/types'\nimport {\n  type CreateIfNotExistsMutation,\n  type CreateMutation,\n  type CreateOrReplaceMutation,\n  type DeleteMutation,\n  type NodePatch,\n  type NodePatchList,\n  type PatchMutation,\n  type PatchOptions,\n  type SanityDocument,\n} from './types'\nimport {NormalizeReadOnlyArray, Optional, Tuplify} from './typeUtils'\n\n/**\n * Creates a new document.\n * @param document - The document to be created.\n * @returns The mutation operation to create the document.\n * @beta\n */\nexport function create<Doc extends Optional<SanityDocument, '_id'>>(\n  document: Doc,\n): CreateMutation<Doc> {\n  return {type: 'create', document}\n}\n\n/**\n * Applies a patch to a document.\n * @param id - The id of the document to be patched.\n * @param patches - The patches to be applied.\n * @param options - Optional patch options.\n * @returns The mutation operation to patch the document.\n * @beta\n */\nexport function patch<P extends NodePatchList | NodePatch>(\n  id: string,\n  patches: P,\n  options?: PatchOptions,\n): PatchMutation<NormalizeReadOnlyArray<Tuplify<P>>> {\n  return {\n    type: 'patch',\n    id,\n    patches: arrify(patches) as any,\n    ...(options ? {options} : {}),\n  }\n}\n\n/**\n * Creates a node patch at a specific path.\n * @param path - The path where the operation should be applied.\n * @param operation - The operation to be applied.\n * @returns The node patch.\n * @beta\n */\nexport function at<O extends Operation>(path: Path | string, operation: O): NodePatch<Path, O> {\n  return {\n    path: typeof path === 'string' ? fromString(path) : path,\n    op: operation,\n  }\n}\n\n/**\n * Creates a document if it does not exist.\n * @param document - The document to be created.\n * @returns The mutation operation to create the document if it does not exist.\n * @beta\n */\nexport function createIfNotExists<Doc extends SanityDocument>(\n  document: Doc,\n): CreateIfNotExistsMutation<Doc> {\n  return {type: 'createIfNotExists', document}\n}\n\n/**\n * Creates or replaces a document.\n * @param document - The document to be created or replaced.\n * @returns The mutation operation to create or replace the document.\n * @beta\n */\nexport function createOrReplace<Doc extends SanityDocument>(\n  document: Doc,\n): CreateOrReplaceMutation<Doc> {\n  return {type: 'createOrReplace', document}\n}\n\n/**\n * Deletes a document.\n * @param id - The id of the document to be deleted.\n * @returns The mutation operation to delete the document.\n * @beta\n */\nexport function delete_(id: string): DeleteMutation {\n  return {type: 'delete', id}\n}\n\n/**\n * Alias for delete_\n */\nexport const del = delete_\n","import arrify from 'arrify'\nimport {AnyArray, ArrayElement, NormalizeReadOnlyArray} from '../typeUtils'\nimport type {\n  DecOp,\n  DiffMatchPatchOp,\n  IncOp,\n  IndexedSegment,\n  InsertOp,\n  KeyedSegment,\n  RelativePosition,\n  ReplaceOp,\n  SetIfMissingOp,\n  SetOp,\n  TruncateOp,\n  UnsetOp,\n} from './types'\n\n/**\n * Creates a `set` operation with the provided value.\n * @param value - The value to set.\n * @returns A `set` operation.\n * {@link https://www.sanity.io/docs/http-patches#6TPENSW3}\n * @beta\n */\nexport const set = <const T>(value: T): SetOp<T> => ({type: 'set', value})\n\n/**\n * Creates a `setIfMissing` operation with the provided value.\n * @param value - The value to set if missing.\n * @returns A `setIfMissing` operation.\n * {@link https://www.sanity.io/docs/http-patches#A80781bT}\n * @beta\n */\nexport const setIfMissing = <const T>(value: T): SetIfMissingOp<T> => ({\n  type: 'setIfMissing',\n  value,\n})\n\n/**\n * Creates an `unset` operation.\n * @returns An `unset` operation.\n * {@link https://www.sanity.io/docs/http-patches#xRtBjp8o}\n * @beta\n */\nexport const unset = (): UnsetOp => ({type: 'unset'})\n\n/**\n * Creates an `inc` (increment) operation with the provided amount.\n * @param amount - The amount to increment by.\n * @returns An `inc` operation.\n * {@link https://www.sanity.io/docs/http-patches#vIT8WWQo}\n * @beta\n */\nexport const inc = <const N extends number = 1>(amount: N = 1 as N): IncOp<N> => ({\n  type: 'inc',\n  amount,\n})\n\n/**\n * Creates a `dec` (decrement) operation with the provided amount.\n * @param amount - The amount to decrement by.\n * @returns A `dec` operation.\n * {@link https://www.sanity.io/docs/http-patches#vIT8WWQo}\n * @beta\n */\nexport const dec = <const N extends number = 1>(amount: N = 1 as N): DecOp<N> => ({\n  type: 'dec',\n  amount,\n})\n\n/**\n * Creates a `diffMatchPatch` operation with the provided value.\n * @param value - The value for the diff match patch operation.\n * @returns A `diffMatchPatch` operation.\n * {@link https://www.sanity.io/docs/http-patches#aTbJhlAJ}\n * @beta\n */\nexport const diffMatchPatch = (value: string): DiffMatchPatchOp => ({\n  type: 'diffMatchPatch',\n  value,\n})\n\n/**\n * Creates an `insert` operation with the provided items, position, and reference item.\n * @param items - The items to insert.\n * @param position - The position to insert at.\n * @param indexOrReferenceItem - The index or reference item to insert before or after.\n * @returns An `insert` operation.\n * {@link https://www.sanity.io/docs/http-patches#febxf6Fk}\n * @beta\n */\nexport function insert<\n  const Items extends AnyArray<unknown>,\n  const Pos extends RelativePosition,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(\n  items: Items | ArrayElement<Items>,\n  position: Pos,\n  indexOrReferenceItem: ReferenceItem,\n): InsertOp<NormalizeReadOnlyArray<Items>, Pos, ReferenceItem> {\n  return {\n    type: 'insert',\n    referenceItem: indexOrReferenceItem,\n    position,\n    items: arrify(items) as any,\n  }\n}\n\n/**\n * Creates an `insert` operation that appends the provided items.\n * @param items - The items to append.\n * @returns An `insert` operation at the end of the array.\n * {@link https://www.sanity.io/docs/http-patches#Cw4vhD88}\n * @beta\n */\nexport function append<const Items extends AnyArray<unknown>>(items: Items | ArrayElement<Items>) {\n  return insert(items, 'after', -1)\n}\n\n/**\n * Creates an `insert` operation that prepends the provided items.\n * @param items - The items to prepend.\n * @returns An `insert` operation at the beginning of the array.\n * {@link https://www.sanity.io/docs/http-patches#refAUsf0}\n * @beta\n */\nexport function prepend<const Items extends AnyArray<unknown>>(items: Items | ArrayElement<Items>) {\n  return insert(items, 'before', 0)\n}\n\n/**\n * Creates an `insert` operation that inserts the provided items before the provided index or reference item.\n * @param items - The items to insert.\n * @param indexOrReferenceItem - The index or reference item to insert before.\n * @returns An `insert` operation before the provided index or reference item.\n * {@link https://www.sanity.io/docs/http-patches#0SQmPlb6}\n */\nexport function insertBefore<\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(items: Items | ArrayElement<Items>, indexOrReferenceItem: ReferenceItem) {\n  return insert(items, 'before', indexOrReferenceItem)\n}\n\n/**\n * Creates an `insert` operation that inserts the provided items after the provided index or reference item.\n * @param items - The items to insert.\n * @param indexOrReferenceItem - The index or reference item to insert after.\n * @returns An `insert` operation after the provided index or reference item.\n * {@link https://www.sanity.io/docs/http-patches#0SQmPlb6}\n * @beta\n */\nexport const insertAfter = <\n  const Items extends AnyArray<unknown>,\n  const ReferenceItem extends IndexedSegment | KeyedSegment,\n>(\n  items: Items | ArrayElement<Items>,\n  indexOrReferenceItem: ReferenceItem,\n) => {\n  return insert(items, 'after', indexOrReferenceItem)\n}\n\n/**\n * Creates a `truncate` operation that will remove all items after `startIndex` until the end of the array or the provided `endIndex`.\n * @param startIndex - The start index for the truncate operation.\n * @param endIndex - The end index for the truncate operation.\n * @returns A `truncate` operation.\n * @remarks - This will be converted to an `unset` patch when submitted to the API\n * {@link https://www.sanity.io/docs/http-patches#xRtBjp8o}\n * @beta\n */\nexport function truncate(startIndex: number, endIndex?: number): TruncateOp {\n  return {\n    type: 'truncate',\n    startIndex,\n    endIndex,\n  }\n}\n\n/**\n * Creates a `replace` operation with the provided items and reference item.\n * @param items - The items to replace.\n * @param referenceItem - The reference item to replace.\n * @returns A ReplaceOp operation.\n * @remarks This will be converted to an `insert`/`replace` patch when submitted to the API\n * {@link https://www.sanity.io/docs/http-patches#GnVSwcPa}\n * @beta\n */\nexport function replace<Items extends any[], ReferenceItem extends IndexedSegment | KeyedSegment>(\n  items: Items | ArrayElement<Items>,\n  referenceItem: ReferenceItem,\n): ReplaceOp<Items, ReferenceItem> {\n  return {\n    type: 'replace',\n    referenceItem,\n    items: arrify(items) as Items,\n  }\n}\n","import {Mutation} from './types'\n\nexport interface Transaction {\n  type: 'transaction'\n  id?: string\n  mutations: Mutation[]\n}\nexport function transaction(id: string, mutations: Mutation[]): Transaction\nexport function transaction(mutations: Mutation[]): Transaction\nexport function transaction(\n  idOrMutations: string | Mutation[],\n  _mutations?: Mutation[],\n): Transaction {\n  const [id, mutations] =\n    typeof idOrMutations === 'string'\n      ? [idOrMutations, _mutations as Mutation[]]\n      : [undefined, idOrMutations as Mutation[]]\n  return {type: 'transaction', id, mutations}\n}\n","export function getValueType(value: unknown) {\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return value === null ? 'null' : typeof value\n}\n","import {Path, PathSegment} from '@sanity/types'\nimport {JsonArray, JsonObject, JsonValue} from '../../json'\nimport {getValueType} from './getValueType'\n\ntype SkipMarker = {_: 'SKIP_MARKER'}\nexport const SKIP_MARKER: SkipMarker = {_: 'SKIP_MARKER'}\n\nfunction callMap<T>(mapFn: MapFn<T>, value: JsonValue, path: Path): T[] {\n  const res = mapFn(value, path)\n  return Array.isArray(res) ? res : [res]\n}\n\nfunction getPathWithKey(\n  item: unknown,\n  index: number | string,\n  container: JsonArray | JsonObject,\n): PathSegment {\n  if (\n    item &&\n    Array.isArray(container) &&\n    typeof item === 'object' &&\n    '_key' in item &&\n    typeof item._key === 'string'\n  ) {\n    return {_key: item._key}\n  }\n  return index\n}\n\ntype MapFn<T> = (value: JsonValue, path: Path) => T | T[]\n\n// Reduce depth first\nfunction mapObject<T>(reducerFn: MapFn<T>, object: JsonObject, path: Path): T[] {\n  return [\n    ...callMap(reducerFn, object, path),\n    ...Object.keys(object).flatMap((key) =>\n      flatMapAny(reducerFn, object[key], path.concat(getPathWithKey(object[key], key, object))),\n    ),\n  ]\n}\n\n// Reduce depth first\nfunction mapArray<T>(mapFn: MapFn<T>, array: JsonArray, path: Path): T[] {\n  return [\n    ...callMap(mapFn, array, path),\n    ...array.flatMap((item: JsonValue, index) =>\n      flatMapAny(mapFn, item, path.concat(getPathWithKey(item, index, array))),\n    ),\n  ]\n}\n\nfunction flatMapAny<T>(mapFn: MapFn<T>, val: JsonValue, path: Path) {\n  const type = getValueType(val)\n  if (type === 'object') {\n    return mapObject(mapFn, val as JsonObject, path)\n  }\n  if (type === 'array') {\n    return mapArray(mapFn, val as JsonArray, path)\n  }\n  return callMap(mapFn, val, path)\n}\n\n/**\n * Iterating depth first over the JSON tree, calling the mapFn for parents before children\n * @param value - the value to map deeply over\n * @param mapFn - the mapFn to call for each value\n */\nexport function flatMapDeep<T>(value: JsonValue, mapFn: MapFn<T>): T[] {\n  return flatMapAny(mapFn, value, [])\n}\n","import {Path, SanityDocument} from '@sanity/types'\nimport type {Mutation as RawMutation} from '@sanity/client'\n\nimport arrify from 'arrify'\nimport {SanityEncoder} from '@bjoerge/mutiny'\nimport {\n  AsyncIterableMigration,\n  Migration,\n  NodeMigration,\n  MigrationContext,\n  NodeMigrationReturnValue,\n} from '../types'\nimport {JsonArray, JsonObject, JsonValue} from '../json'\nimport {at, Mutation, patch, NodePatch, Operation, Transaction} from '../mutations'\nimport {isMutation, isTransaction} from '../mutations/asserters'\nimport {flatMapDeep} from './utils/flatMapDeep'\nimport {getValueType} from './utils/getValueType'\n\nexport function normalizeMigrateDefinition(migration: Migration): AsyncIterableMigration {\n  if (typeof migration.migrate == 'function') {\n    // assume AsyncIterableMigration\n    return normalizeIteratorValues(migration.migrate)\n  }\n  return createAsyncIterableMutation(migration.migrate, {\n    filter: migration.filter,\n    documentTypes: migration.documentTypes,\n  })\n}\n\nfunction normalizeIteratorValues(asyncIterable: AsyncIterableMigration): AsyncIterableMigration {\n  return async function* run(docs, context) {\n    for await (const documentMutations of asyncIterable(docs, context)) {\n      yield normalizeMutation(documentMutations)\n    }\n  }\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param documentId - The document id\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeMutation(\n  change: Transaction | Mutation | RawMutation | (Mutation | Transaction | RawMutation)[],\n): (Mutation | Transaction)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeMutation(ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any) as Mutation[]\n  }\n  return [change]\n}\n\nfunction isRawMutation(\n  mutation: Transaction | Mutation | NodePatch | Operation | RawMutation,\n): mutation is RawMutation {\n  return (\n    'createIfNotExists' in mutation ||\n    'createOrReplace' in mutation ||\n    'create' in mutation ||\n    'patch' in mutation ||\n    'delete' in mutation\n  )\n}\n\nfunction isOperation(value: Mutation | NodePatch | Operation): value is Operation {\n  return (\n    'type' in value &&\n    (value.type === 'set' ||\n      value.type === 'unset' ||\n      value.type === 'insert' ||\n      value.type === 'diffMatchPatch' ||\n      value.type === 'dec' ||\n      value.type === 'inc' ||\n      value.type === 'upsert' ||\n      value.type === 'unassign' ||\n      value.type === 'truncate' ||\n      value.type === 'setIfMissing')\n  )\n}\n\nexport function createAsyncIterableMutation(\n  migration: NodeMigration,\n  opts: {filter?: string; documentTypes?: string[]},\n): AsyncIterableMigration {\n  const documentTypesSet = new Set(opts.documentTypes)\n\n  return async function* run(docs, context) {\n    for await (const doc of docs()) {\n      if (opts.documentTypes && !documentTypesSet.has(doc._type)) continue\n\n      const documentMutations = await collectDocumentMutations(migration, doc, context)\n      if (documentMutations.length > 0) {\n        yield documentMutations\n      }\n    }\n  }\n}\n\nasync function collectDocumentMutations(\n  migration: NodeMigration,\n  doc: SanityDocument,\n  context: MigrationContext,\n): Promise<(Mutation | Transaction)[]> {\n  const documentMutations = Promise.resolve(migration.document?.(doc, context))\n  const nodeMigrations = flatMapDeep(doc as JsonValue, async (value, path) => {\n    const [nodeReturnValues, nodeTypeReturnValues] = await Promise.all([\n      Promise.resolve(migration.node?.(value, path, context)),\n      Promise.resolve(migrateNodeType(migration, value, path, context)),\n    ])\n\n    return [...arrify(nodeReturnValues), ...arrify(nodeTypeReturnValues)].map(\n      (change) => change && normalizeNodeMutation(path, change),\n    )\n  })\n\n  return (await Promise.all([...arrify(await documentMutations), ...nodeMigrations]))\n    .flat()\n    .flatMap((change) => (change ? normalizeDocumentMutation(doc._id, change) : []))\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param documentId - The document id\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeDocumentMutation(\n  documentId: string,\n  change:\n    | Transaction\n    | Mutation\n    | NodePatch\n    | RawMutation\n    | (Mutation | NodePatch | Transaction | RawMutation)[],\n): Mutation | Transaction | (Mutation | Transaction)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeDocumentMutation(documentId, ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any)[0] as Mutation\n  }\n  if (isTransaction(change)) {\n    return change\n  }\n  return isMutation(change) ? change : patch(documentId, change)\n}\n\n/**\n * Normalize a mutation or a NodePatch to a document mutation\n * @param path - The path the operation should be applied at\n * @param change - The Mutation or NodePatch\n */\nfunction normalizeNodeMutation(\n  path: Path,\n  change: Mutation | NodePatch | Operation | RawMutation | RawMutation[],\n): Mutation | NodePatch | (Mutation | NodePatch)[] {\n  if (Array.isArray(change)) {\n    return change.flatMap((ch) => normalizeNodeMutation(path, ch))\n  }\n  if (isRawMutation(change)) {\n    return SanityEncoder.decode([change] as any)[0] as Mutation\n  }\n\n  return isOperation(change) ? at(path, change) : change\n}\n\nfunction migrateNodeType(\n  migration: NodeMigration,\n  value: JsonValue,\n  path: Path,\n  context: MigrationContext,\n): void | NodeMigrationReturnValue | Promise<void | NodeMigrationReturnValue> {\n  switch (getValueType(value)) {\n    case 'string':\n      return migration.string?.(value as string, path, context)\n    case 'number':\n      return migration.number?.(value as number, path, context)\n    case 'boolean':\n      return migration.boolean?.(value as boolean, path, context)\n    case 'object':\n      return migration.object?.(value as JsonObject, path, context)\n    case 'array':\n      return migration.array?.(value as JsonArray, path, context)\n    case 'null':\n      return migration.null?.(value as null, path, context)\n    default:\n      throw new Error('Unknown value type')\n  }\n}\n","import {SanityDocument} from '@sanity/types'\nimport {Migration, MigrationContext} from '../types'\nimport {normalizeMigrateDefinition} from './normalizeMigrateDefinition'\n\nexport function collectMigrationMutations(\n  migration: Migration,\n  documents: () => AsyncIterableIterator<SanityDocument>,\n  context: MigrationContext,\n) {\n  const migrate = normalizeMigrateDefinition(migration)\n  return migrate(documents, context)\n}\n","import {tmpdir} from 'node:os'\nimport path from 'node:path'\n\nexport function getBufferFilePath() {\n  return path.join(tmpdir(), `/export-buffer-${Date.now()}.tmp`)\n}\n","import {SanityDocument} from '@sanity/types'\nimport {MigrationContext} from '../../types'\nimport {decodeText, JSONParser, parse} from '../../it-utils'\nimport {streamToAsyncIterator} from '../../utils/streamToAsyncIterator'\nimport {safeJsonParser} from '../../sources/fromExportEndpoint'\n\nexport function createFilteredDocumentsClient(\n  getFilteredDocumentsReadableStream: () => ReadableStream<Uint8Array>,\n): MigrationContext['filtered'] {\n  function getAllDocumentsFromBuffer<T extends SanityDocument>() {\n    return parse<T>(decodeText(streamToAsyncIterator(getFilteredDocumentsReadableStream())), {\n      parse: safeJsonParser as JSONParser<T>,\n    })\n  }\n\n  async function getDocumentsFromBuffer<T extends SanityDocument>(ids: string[]): Promise<T[]> {\n    const found: {[id: string]: T} = {}\n    let remaining = ids.length\n    for await (const doc of getAllDocumentsFromBuffer<T>()) {\n      if (ids.includes(doc._id)) {\n        remaining--\n        found[doc._id] = doc\n      }\n      if (remaining === 0) break\n    }\n    return ids.map((id) => found[id])\n  }\n\n  async function getDocumentFromBuffer<T extends SanityDocument>(\n    id: string,\n  ): Promise<T | undefined> {\n    return (await getDocumentsFromBuffer<T>([id]))[0]\n  }\n\n  return {\n    getDocument: getDocumentFromBuffer,\n    getDocuments: getDocumentsFromBuffer,\n  }\n}\n","import {SanityDocument} from '@sanity/types'\nimport groq, {type ExprNode} from 'groq-js'\nimport {Migration} from '../../types'\nimport {groqFilter} from '../../it-utils/groqFilter'\n\nfunction isSystemDocumentId(id: string) {\n  return id.startsWith('_.')\n}\n\nasync function* filterDocumentTypes(\n  documents: AsyncIterableIterator<SanityDocument>,\n  types: string[],\n) {\n  for await (const doc of documents) {\n    if (types.includes(doc._type)) {\n      yield doc\n    }\n  }\n}\n\nfunction parseGroqFilter(filter: string) {\n  try {\n    return groq.parse(`*[${filter}]`)\n  } catch (err) {\n    err.message = `Failed to parse GROQ filter \"${filter}\": ${err.message}`\n    throw err\n  }\n}\n\nexport async function matchesFilter(parsedFilter: ExprNode, document: SanityDocument) {\n  const result = await (await groq.evaluate(parsedFilter, {dataset: [document]})).get()\n  return result.length === 1\n}\n\nexport async function* applyFilters(\n  migration: Migration,\n  documents: AsyncIterableIterator<SanityDocument>,\n) {\n  const documentTypes = migration.documentTypes\n  const parsedFilter = migration.filter ? parseGroqFilter(migration.filter) : undefined\n\n  for await (const doc of documents) {\n    if (isSystemDocumentId(doc._id)) {\n      continue\n    }\n    if (documentTypes && documentTypes.length > 0 && !documentTypes.includes(doc._type)) {\n      continue\n    }\n    if (parsedFilter && !(await matchesFilter(parsedFilter, doc))) {\n      continue\n    }\n    yield doc\n  }\n}\n","/**\n * ConcurrencyLimiter manages the number of concurrent operations that can be performed.\n * It ensures that the number of operations does not exceed a specified maximum limit.\n */\nexport class ConcurrencyLimiter {\n  current = 0\n  resolvers: Array<() => void> = []\n  constructor(public max: number) {}\n\n  /**\n   * Indicates when a slot for a new operation is ready.\n   * If under the limit, it resolves immediately; otherwise, it waits until a slot is free.\n   */\n  ready = (): Promise<void> => {\n    if (this.max === Infinity) return Promise.resolve()\n\n    if (this.current < this.max) {\n      this.current++\n      return Promise.resolve()\n    }\n\n    return new Promise<void>((resolve) => {\n      this.resolvers.push(resolve)\n    })\n  }\n\n  /**\n   * Releases a slot, decrementing the current count of operations if nothing is in the queue.\n   * If there are operations waiting, it allows the next one in the queue to proceed.\n   */\n  release = (): void => {\n    if (this.max === Infinity) return\n\n    const nextResolver = this.resolvers.shift()\n    if (nextResolver) {\n      nextResolver()\n      return\n    }\n\n    this.current = Math.max(0, this.current - 1)\n  }\n}\n","import type {SanityClient, ObservableSanityClient} from '@sanity/client'\nimport {from, switchMap, finalize} from 'rxjs'\nimport {ConcurrencyLimiter} from './ConcurrencyLimiter'\n\n/**\n * Decorates a sanity client to limit the concurrency of `client.fetch`\n * requests. Keeps the concurrency limit state and returns wrapped clients with\n * that same state if the `clone` `config` or `withConfig` methods are called.\n */\nexport function createClientConcurrencyLimiter(\n  maxConcurrency: number,\n): (input: SanityClient) => SanityClient {\n  const limiter = new ConcurrencyLimiter(maxConcurrency)\n\n  function wrapClient(client: SanityClient): SanityClient {\n    return new Proxy(client, {\n      get: (target, property) => {\n        switch (property) {\n          case 'fetch': {\n            return async (...args: Parameters<SanityClient['fetch']>) => {\n              await limiter.ready()\n              try {\n                // note we want to await before we return so the finally block\n                // will run after the promise has been fulfilled or rejected\n                return await target.fetch(...args)\n              } finally {\n                limiter.release()\n              }\n            }\n          }\n          case 'clone': {\n            return (...args: Parameters<SanityClient['clone']>) => {\n              return wrapClient(target.clone(...args))\n            }\n          }\n          case 'config': {\n            return (...args: Parameters<SanityClient['config']>) => {\n              const result = target.config(...args)\n\n              // if there is a config, it returns a client so we need to wrap again\n              if (args[0]) return wrapClient(result)\n              return result\n            }\n          }\n          case 'withConfig': {\n            return (...args: Parameters<SanityClient['withConfig']>) => {\n              return wrapClient(target.withConfig(...args))\n            }\n          }\n          case 'observable': {\n            return wrapObservableClient(target.observable)\n          }\n          default: {\n            return target[property as keyof SanityClient]\n          }\n        }\n      },\n    })\n  }\n\n  function wrapObservableClient(\n    observableSanityClient: ObservableSanityClient,\n  ): ObservableSanityClient {\n    return new Proxy(observableSanityClient, {\n      get: (target, property) => {\n        switch (property) {\n          case 'fetch': {\n            return (...args: Parameters<ObservableSanityClient['fetch']>) =>\n              from(limiter.ready()).pipe(\n                switchMap(() => target.fetch(...args)),\n                finalize(() => limiter.release()),\n              )\n          }\n          case 'clone': {\n            return (...args: Parameters<ObservableSanityClient['clone']>) => {\n              return wrapObservableClient(target.clone(...args))\n            }\n          }\n          case 'config': {\n            return (...args: Parameters<ObservableSanityClient['config']>) => {\n              const result = target.config(...args)\n\n              // if there is a config, it returns a client so we need to wrap again\n              if (args[0]) return wrapObservableClient(result)\n              return result\n            }\n          }\n          case 'withConfig': {\n            return (...args: Parameters<ObservableSanityClient['withConfig']>) => {\n              return wrapObservableClient(target.withConfig(...args))\n            }\n          }\n          default: {\n            return target[property as keyof ObservableSanityClient]\n          }\n        }\n      },\n    })\n  }\n\n  return wrapClient\n}\n","// this is the number of requests allowed inflight at once. this is done to prevent\n// the validation library from overwhelming our backend\nimport {createClientConcurrencyLimiter} from './client-concurrency-limiter/createClientConcurrencyLimiter'\n\nconst MAX_FETCH_CONCURRENCY = 10\n\nexport const limitClientConcurrency = createClientConcurrencyLimiter(MAX_FETCH_CONCURRENCY)\n","import {createClient, type SanityClient} from '@sanity/client'\nimport {limitClientConcurrency} from './limitClientConcurrency'\n\nexport function createContextClient(config: Parameters<typeof createClient>[0]): RestrictedClient {\n  return restrictClient(\n    limitClientConcurrency(\n      createClient({...config, useCdn: false, requestTagPrefix: 'sanity.migration'}),\n    ),\n  )\n}\n\nconst ALLOWED_PROPERTIES = [\n  'fetch',\n  'clone',\n  'config',\n  'withConfig',\n  'getDocument',\n  'getDocuments',\n  'users',\n  'projects',\n] as const\n\ntype AllowedMethods = (typeof ALLOWED_PROPERTIES)[number]\n\nexport type RestrictedClient = Pick<SanityClient, AllowedMethods>\n\nfunction restrictClient(client: SanityClient): RestrictedClient {\n  return new Proxy(client, {\n    get: (target, property) => {\n      switch (property) {\n        case 'clone': {\n          return (...args: Parameters<SanityClient['clone']>) => {\n            return restrictClient(target.clone(...args))\n          }\n        }\n        case 'config': {\n          return (...args: Parameters<SanityClient['config']>) => {\n            const result = target.config(...args)\n\n            // if there is a config, it returns a client so we need to wrap again\n            if (args[0]) return restrictClient(result)\n            return result\n          }\n        }\n        case 'withConfig': {\n          return (...args: Parameters<SanityClient['withConfig']>) => {\n            return restrictClient(target.withConfig(...args))\n          }\n        }\n        default: {\n          if (ALLOWED_PROPERTIES.includes(property as any)) {\n            return target[property as keyof SanityClient]\n          }\n          throw new Error(\n            `Client method \"${String(\n              property,\n            )}\" can not be called during a migration. Only ${ALLOWED_PROPERTIES.join(\n              ', ',\n            )} are allowed.`,\n          )\n        }\n      }\n    },\n  })\n}\n","import {SanityDocument} from '@sanity/types'\nimport {MultipleMutationResult} from '@sanity/client'\nimport arrify from 'arrify'\nimport {APIConfig, Migration, MigrationProgress} from '../types'\nimport {parse, stringify} from '../it-utils/ndjson'\nimport {fromExportEndpoint, safeJsonParser} from '../sources/fromExportEndpoint'\nimport {endpoints} from '../fetch-utils/endpoints'\nimport {toFetchOptions} from '../fetch-utils/sanityRequestOptions'\nimport {tap} from '../it-utils/tap'\nimport {mapAsync} from '../it-utils/mapAsync'\nimport {lastValueFrom} from '../it-utils/lastValueFrom'\nimport {decodeText, parseJSON} from '../it-utils'\nimport {concatStr} from '../it-utils/concatStr'\nimport {fetchAsyncIterator, FetchOptions} from '../fetch-utils/fetchStream'\nimport {bufferThroughFile} from '../fs-webstream/bufferThroughFile'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {asyncIterableToStream} from '../utils/asyncIterableToStream'\nimport {toSanityMutations, TransactionPayload} from './utils/toSanityMutations'\nimport {\n  DEFAULT_MUTATION_CONCURRENCY,\n  MAX_MUTATION_CONCURRENCY,\n  MUTATION_ENDPOINT_MAX_BODY_SIZE,\n} from './constants'\nimport {batchMutations} from './utils/batchMutations'\nimport {collectMigrationMutations} from './collectMigrationMutations'\nimport {getBufferFilePath} from './utils/getBufferFile'\nimport {createFilteredDocumentsClient} from './utils/createFilteredDocumentsClient'\nimport {applyFilters} from './utils/applyFilters'\nimport {createContextClient} from './utils/createContextClient'\n\nexport interface MigrationRunnerConfig {\n  api: APIConfig\n  concurrency?: number\n  onProgress?: (event: MigrationProgress) => void\n}\n\nexport async function* toFetchOptionsIterable(\n  apiConfig: APIConfig,\n  mutations: AsyncIterableIterator<TransactionPayload>,\n) {\n  for await (const transaction of mutations) {\n    yield toFetchOptions({\n      projectId: apiConfig.projectId,\n      apiVersion: apiConfig.apiVersion,\n      token: apiConfig.token,\n      tag: 'sanity.migration.mutate',\n      apiHost: apiConfig.apiHost ?? 'api.sanity.io',\n      endpoint: endpoints.data.mutate(apiConfig.dataset, {returnIds: true}),\n      body: JSON.stringify(transaction),\n    })\n  }\n}\n\nexport async function run(config: MigrationRunnerConfig, migration: Migration) {\n  const stats: MigrationProgress = {\n    documents: 0,\n    mutations: 0,\n    pending: 0,\n    queuedBatches: 0,\n    completedTransactions: [],\n    currentTransactions: [],\n  }\n\n  const filteredDocuments = applyFilters(\n    migration,\n    parse<SanityDocument>(\n      decodeText(\n        streamToAsyncIterator(\n          await fromExportEndpoint({...config.api, documentTypes: migration.documentTypes}),\n        ),\n      ),\n      {parse: safeJsonParser},\n    ),\n  )\n  const abortController = new AbortController()\n\n  const createReader = bufferThroughFile(\n    asyncIterableToStream(stringify(filteredDocuments)),\n    getBufferFilePath(),\n    {signal: abortController.signal},\n  )\n\n  const client = createContextClient({\n    ...config.api,\n    useCdn: false,\n    requestTagPrefix: 'sanity.migration',\n  })\n\n  const filteredDocumentsClient = createFilteredDocumentsClient(createReader)\n  const context = {\n    client,\n    filtered: filteredDocumentsClient,\n  }\n\n  const documents = () =>\n    tap(\n      parse<SanityDocument>(decodeText(streamToAsyncIterator(createReader())), {\n        parse: safeJsonParser,\n      }),\n      () => {\n        config.onProgress?.({...stats, documents: ++stats.documents})\n      },\n    )\n\n  const mutations = tap(collectMigrationMutations(migration, documents, context), (muts) => {\n    stats.currentTransactions = arrify(muts)\n    config.onProgress?.({\n      ...stats,\n      mutations: ++stats.mutations,\n    })\n  })\n\n  const concurrency = config?.concurrency ?? DEFAULT_MUTATION_CONCURRENCY\n\n  if (concurrency > MAX_MUTATION_CONCURRENCY) {\n    throw new Error(`Concurrency exceeds maximum allowed value (${MAX_MUTATION_CONCURRENCY})`)\n  }\n\n  const batches = tap(\n    batchMutations(toSanityMutations(mutations), MUTATION_ENDPOINT_MAX_BODY_SIZE),\n    () => {\n      config.onProgress?.({...stats, queuedBatches: ++stats.queuedBatches})\n    },\n  )\n\n  const submit = async (opts: FetchOptions): Promise<MultipleMutationResult> =>\n    lastValueFrom(parseJSON(concatStr(decodeText(await fetchAsyncIterator(opts)))))\n\n  const commits = await mapAsync(\n    toFetchOptionsIterable(config.api, batches),\n    (opts) => {\n      config.onProgress?.({...stats, pending: ++stats.pending})\n      return submit(opts)\n    },\n    concurrency,\n  )\n\n  for await (const result of commits) {\n    stats.completedTransactions.push(result)\n    config.onProgress?.({\n      ...stats,\n    })\n  }\n  config.onProgress?.({\n    ...stats,\n    done: true,\n  })\n\n  // Cancel export/buffer stream, it's not needed anymore\n  abortController.abort()\n}\n","import {SanityDocument} from '@sanity/types'\nimport arrify from 'arrify'\nimport {Migration, MigrationProgress} from '../types'\nimport {decodeText} from '../it-utils'\nimport {fromExportArchive} from '../sources/fromExportArchive'\nimport {bufferThroughFile} from '../fs-webstream/bufferThroughFile'\nimport {tap} from '../it-utils/tap'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {mapAsync} from '../it-utils/mapAsync'\nimport {asyncIterableToStream} from '../utils/asyncIterableToStream'\nimport {safeJsonParser} from '../sources/fromExportEndpoint'\nimport {parse, stringify} from '../it-utils/ndjson'\nimport {toSanityMutations} from './utils/toSanityMutations'\nimport {batchMutations} from './utils/batchMutations'\nimport {\n  DEFAULT_MUTATION_CONCURRENCY,\n  MAX_MUTATION_CONCURRENCY,\n  MUTATION_ENDPOINT_MAX_BODY_SIZE,\n} from './constants'\nimport {createFilteredDocumentsClient} from './utils/createFilteredDocumentsClient'\nimport {getBufferFilePath} from './utils/getBufferFile'\nimport {collectMigrationMutations} from './collectMigrationMutations'\nimport {MigrationRunnerConfig, toFetchOptionsIterable} from './run'\nimport {applyFilters} from './utils/applyFilters'\nimport {createContextClient} from './utils/createContextClient'\n\nexport async function runFromArchive(\n  migration: Migration,\n  path: string,\n  config: MigrationRunnerConfig,\n) {\n  const stats: MigrationProgress = {\n    documents: 0,\n    mutations: 0,\n    pending: 0,\n    queuedBatches: 0,\n    completedTransactions: [],\n    currentTransactions: [],\n  }\n\n  const filteredDocuments = applyFilters(\n    migration,\n    parse<SanityDocument>(decodeText(fromExportArchive(path)), {\n      parse: safeJsonParser,\n    }),\n  )\n  const abortController = new AbortController()\n\n  const createReader = bufferThroughFile(\n    asyncIterableToStream(stringify(filteredDocuments)),\n    getBufferFilePath(),\n    {signal: abortController.signal},\n  )\n  const documents = () =>\n    tap(\n      parse<SanityDocument>(decodeText(streamToAsyncIterator(createReader())), {\n        parse: safeJsonParser,\n      }),\n      () => {\n        config.onProgress?.({...stats, documents: ++stats.documents})\n      },\n    )\n\n  const client = createContextClient({...config.api, useCdn: false})\n\n  const filteredDocumentsClient = createFilteredDocumentsClient(createReader)\n  const context = {\n    client,\n    filtered: filteredDocumentsClient,\n  }\n\n  const payloads = tap(collectMigrationMutations(migration, documents, context), (muts) => {\n    stats.currentTransactions = arrify(muts)\n    config.onProgress?.({\n      ...stats,\n      mutations: ++stats.mutations,\n    })\n  })\n\n  const batches = tap(\n    batchMutations(toSanityMutations(payloads), MUTATION_ENDPOINT_MAX_BODY_SIZE),\n    () => {\n      config.onProgress?.({...stats, queuedBatches: ++stats.queuedBatches})\n    },\n  )\n\n  const concurrency = config?.concurrency ?? DEFAULT_MUTATION_CONCURRENCY\n\n  if (concurrency > MAX_MUTATION_CONCURRENCY) {\n    throw new Error(`Concurrency exceeds maximum allowed value (${MAX_MUTATION_CONCURRENCY})`)\n  }\n\n  const commits = await mapAsync(\n    toFetchOptionsIterable(config.api, batches),\n    (opts) => {\n      config.onProgress?.({...stats, pending: ++stats.pending})\n      return Promise.resolve()\n    },\n    concurrency,\n  )\n  for await (const result of commits) {\n    config.onProgress?.({\n      ...stats,\n    })\n  }\n  // Cancel export/buffer stream, it's not needed anymore\n  abortController.abort()\n  config.onProgress?.({\n    ...stats,\n    done: true,\n  })\n}\n","import {SanityDocument} from '@sanity/types'\nimport {APIConfig, Migration, MigrationProgress} from '../types'\nimport {fromExportEndpoint, safeJsonParser} from '../sources/fromExportEndpoint'\nimport {streamToAsyncIterator} from '../utils/streamToAsyncIterator'\nimport {bufferThroughFile} from '../fs-webstream/bufferThroughFile'\nimport {asyncIterableToStream} from '../utils/asyncIterableToStream'\nimport {parse, stringify} from '../it-utils/ndjson'\nimport {decodeText} from '../it-utils'\nimport {collectMigrationMutations} from './collectMigrationMutations'\nimport {getBufferFilePath} from './utils/getBufferFile'\nimport {createFilteredDocumentsClient} from './utils/createFilteredDocumentsClient'\nimport {applyFilters} from './utils/applyFilters'\nimport {createContextClient} from './utils/createContextClient'\n\ninterface MigrationRunnerOptions {\n  api: APIConfig\n  onProgress?: (event: MigrationProgress) => void\n}\n\nexport async function* dryRun(config: MigrationRunnerOptions, migration: Migration) {\n  const filteredDocuments = applyFilters(\n    migration,\n    parse<SanityDocument>(\n      decodeText(\n        streamToAsyncIterator(\n          await fromExportEndpoint({...config.api, documentTypes: migration.documentTypes}),\n        ),\n      ),\n      {parse: safeJsonParser},\n    ),\n  )\n\n  const abortController = new AbortController()\n\n  const createReader = bufferThroughFile(\n    asyncIterableToStream(stringify(filteredDocuments)),\n    getBufferFilePath(),\n    {signal: abortController.signal},\n  )\n\n  // Create a client exposed to the migration script. This will have a max concurrency of 10\n  const client = createContextClient({...config.api, useCdn: false})\n\n  const filteredDocumentsClient = createFilteredDocumentsClient(createReader)\n  const context = {\n    client,\n    filtered: filteredDocumentsClient,\n  }\n\n  yield* collectMigrationMutations(\n    migration,\n    () => parse(decodeText(streamToAsyncIterator(createReader())), {parse: safeJsonParser}),\n    context,\n  )\n\n  // stop buffering the export once we're done collecting all mutations\n  abortController.abort()\n}\n"],"names":["objectToString","Object","prototype","toString","uint8ArrayStringified","isUint8Array","value","constructor","Uint8Array","call","assertUint8Array","TypeError","concat","concatUint8Arrays","arrays","totalLength","length","reduce","accumulator","currentValue","returnValue","offset","array","set","areUint8ArraysEqual","a","b","index","peekInto","readable","options","size","Promise","resolve","reject","totalBytesRead","streamCompleted","chunks","reader","getReader","settled","head","ReadableStream","start","controller","enqueue","close","pull","done","read","chunk","byteLength","push","then","isGzip","buffer","isDeflate","buf","maybeDecompress","stream","pipeThrough","DecompressionStream","EMPTY","BufferList","buffered","shifted","queue","FIFO","_offset","shiftFirst","_next","shift","peek","rem","sub","subarray","ZERO_OFFSET","charCodeAt","USTAR_MAGIC","GNU_MAGIC","GNU_VER","MAGIC_OFFSET","VERSION_OFFSET","decode","filenameEncoding","allowUnknownFormat","typeflag","name","decodeStr","mode","decodeOct","uid","gid","mtime","type","toType","linkname","uname","gname","devmajor","devminor","c","cksum","Error","isUSTAR","isGNU","Date","clamp","len","defaultValue","flag","indexOf","block","num","end","sum","i","j","parse256","positive","tuple","byte","l","Math","pow","decoders","getCachedDecoder","encoding","TextDecoder","uint8","arguments","undefined","val","parseInt","emptyReadableStream","untar","readingChunk","_a","_b","headerChunk","header","headers.decode","entryStream","expectedBytes","next","remaining","discardPadding","getPadding","bl","overflow","streamToAsyncIterator","releaseLock","createDebug","debug","baseDebug","extend","readFileAsWebStream","filename","CHUNK_SIZE","fileHandle","position","open","bytesRead","cancel","fromExportArchive","path","entry","endsWith","assert2xx","res","status","response","json","catch","statusText","message","error","description","err","statusCode","fetchStream","_ref","url","init","fetch","body","fetchAsyncIterator","getUserAgent","window","pkg","require","version","normalizeApiHost","apiHost","replace","toFetchOptions","req","endpoint","apiVersion","tag","projectId","token","requestInit","method","headers","ua","Authorization","normalizedApiHost","host","global","searchParams","URLSearchParams","endpoints","users","me","data","query","dataset","export","documentTypes","join","mutate","params","returnIds","returnDocuments","visiblity","dryRun","filter","Boolean","fromExportEndpoint","safeJsonParser","createSafeJsonParser","errorLabel","fromDocuments","documents","document","defineMigration","migration","decodeText","it","decoder","sleep","ms","setTimeout","delay","parseJSON","parse","JSON","e","stringifyJSON","stringify","predicate","map","project","split","delimiter","includes","lastIndex","lastIndexOf","parts","substring","part","line","trim","iterable","doc","take","count","toArray","result","tap","interceptor","mapAsync","concurrency","pMapIterable","v","lastValueFrom","defaultGiven","latestValue","didYield","concatStr","bufferThroughFile","source","signal","writeHandle","readHandle","bufferDone","addEventListener","all","readerCount","ready","pump","aborted","write","createBufferedReader","tryReadFromBuffer","handle","getReadHandle","onReaderStart","onReaderEnd","readChunk","asyncIterableToStream","isMutation","mutation","isTransaction","toSanityMutations","mut","arrify","transactionId","id","mutations","SanityEncoder","encode","MUTATION_ENDPOINT_MAX_BODY_SIZE","DEFAULT_MUTATION_CONCURRENCY","MAX_MUTATION_CONCURRENCY","PADDING_SIZE","isTransactionPayload","payload","Array","isArray","batchMutations","maxBatchSize","currentBatch","currentBatchSize","mutationSize","default","create","patch","patches","at","operation","fromString","op","createIfNotExists","createOrReplace","delete_","del","setIfMissing","unset","inc","amount","dec","diffMatchPatch","insert","items","indexOrReferenceItem","referenceItem","append","prepend","insertBefore","insertAfter","truncate","startIndex","endIndex","transaction","idOrMutations","_mutations","getValueType","callMap","mapFn","getPathWithKey","item","container","_key","mapObject","reducerFn","object","keys","flatMap","key","flatMapAny","mapArray","flatMapDeep","normalizeMigrateDefinition","migrate","normalizeIteratorValues","createAsyncIterableMutation","asyncIterable","run","docs","context","documentMutations","normalizeMutation","change","ch","isRawMutation","isOperation","opts","documentTypesSet","Set","has","_type","collectDocumentMutations","nodeMigrations","nodeReturnValues","nodeTypeReturnValues","node","migrateNodeType","normalizeNodeMutation","flat","normalizeDocumentMutation","_id","documentId","_c","_d","_e","_f","string","number","boolean","null","collectMigrationMutations","getBufferFilePath","tmpdir","now","createFilteredDocumentsClient","getFilteredDocumentsReadableStream","getAllDocumentsFromBuffer","getDocumentsFromBuffer","ids","found","getDocumentFromBuffer","getDocument","getDocuments","isSystemDocumentId","startsWith","parseGroqFilter","groq","matchesFilter","parsedFilter","evaluate","get","applyFilters","ConcurrencyLimiter","max","current","resolvers","Infinity","release","nextResolver","createClientConcurrencyLimiter","maxConcurrency","limiter","wrapClient","client","Proxy","target","property","clone","config","withConfig","wrapObservableClient","observable","observableSanityClient","_len","args","from","pipe","switchMap","finalize","MAX_FETCH_CONCURRENCY","limitClientConcurrency","createContextClient","restrictClient","createClient","useCdn","requestTagPrefix","ALLOWED_PROPERTIES","String","toFetchOptionsIterable","apiConfig","stats","pending","queuedBatches","completedTransactions","currentTransactions","filteredDocuments","api","abortController","AbortController","createReader","filteredDocumentsClient","filtered","onProgress","muts","batches","submit","commits","abort","runFromArchive","payloads"],"mappings":"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"}