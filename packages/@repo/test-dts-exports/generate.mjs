import fs from 'node:fs'
import {writeFile} from 'node:fs/promises'
import path from 'node:path'
import {fileURLToPath} from 'node:url'

import rootJson from '@repo/test-dts-exports/package.json' with {type: 'json'}
import {format as prettierFormat, resolveConfig as resolvePrettierConfig} from 'prettier'
import {Project} from 'ts-morph'

const diagnosticsEnvFlag = process.env.TEST_DTS_EXPORTS_DIAGNOSTICS || 'none'
const diagnostics =
  diagnosticsEnvFlag === 'full'
    ? 'full'
    : diagnosticsEnvFlag === 'duplicates'
      ? 'duplicates'
      : 'none'

const {dependencies} = rootJson

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const fixturesDir = path.join(__dirname, 'test', 'fixtures')
if (!fs.existsSync(fixturesDir)) {
  fs.mkdirSync(fixturesDir, {recursive: true})
}

const fixtures = new Map()

for (const packageName of Object.keys(dependencies)) {
  const {default: packageJson} = await import(`${packageName}/package.json`, {with: {type: 'json'}})
  if (!packageJson.exports) {
    continue
  }
  for (const [key, value] of Object.entries(packageJson.exports)) {
    if (typeof value === 'object' && 'default' in value) {
      const bareIdentifier = path.join(packageName, key)
      const dtsFilePath = path.join(packageName, value.default).replace(/\.(m|c)?js$/, '.d.ts')
      const fixtureName = bareIdentifier.replaceAll('/', '.')
      const fixturePath = path.join(fixturesDir, `${fixtureName}.test-d.ts`)
      console.log(`${bareIdentifier} -> ${dtsFilePath} -> ${path.relative(__dirname, fixturePath)}`)
      fixtures.set(bareIdentifier, [dtsFilePath, fixturePath])
    }
  }
}

const prettierConfig = await resolvePrettierConfig(path.join(fixturesDir, 'mock.test-d.ts'))

for (const [bareIdentifier, [dtsFilePath, fixturePath]] of fixtures) {
  const project = new Project()
  const sourceFile = project.addSourceFileAtPath(`../../../packages/${dtsFilePath}`)
  const exps = sourceFile.getExportedDeclarations()
  if (exps.size === 0) {
    console.warn(`No exports found for ${bareIdentifier}`)
    continue
  }

  const imports = Array.from(exps.keys()).sort((a, b) => a.localeCompare(b))

  // Generate the test content
  let testContent = `// Auto-generated by running \`pnpm generate:dts-exports\`
// If deleting the exports, for example, then please use this command to regenerate the tests
// If you need to investigate where new imports are coming from run \`TEST_DTS_EXPORTS_DIAGNOSTICS=full pnpm generate:dts-exports\`

import { describe, expectTypeOf, test } from "vitest";
import type { ${imports
    .map((name) => (name === 'default' ? 'default as _default' : name))
    .join(', ')} } from "${bareIdentifier}";


describe(${JSON.stringify(bareIdentifier)}, () => {
`

  for (const name of imports) {
    const exportName = name === 'default' ? '_default' : name
    const testName = JSON.stringify(name)
    const decls = exps.get(name)
    if (!decls || decls.length === 0) {
      testContent += `test.todo(${testName} /* FIXME: no declarations found */)
`

      continue
    }

    testContent += `test(${JSON.stringify(name)}, () => {
`

    const dedupeTestContent = new Set()

    if (decls.length > 1) {
      testContent += `// This export has ${decls.length} declarations, run \`TEST_DTS_EXPORTS_DIAGNOSTICS=duplicates pnpm generate:dts-exports\` to see where each declaration is coming from
`
    }

    for (const decl of decls) {
      const syntaxKindName = decl.getKindName()
      const genericParamsCount = decl.getTypeParameters?.().length ?? 0
      const genericParams =
        genericParamsCount > 0 ? `<${Array(genericParamsCount).fill('any').join(', ')}>` : ''
      const testContentDecl = getTestContent(syntaxKindName, exportName, genericParams)
      if (!dedupeTestContent.has(testContentDecl)) {
        testContent += testContentDecl
        dedupeTestContent.add(testContentDecl)
      }
      if (diagnostics === 'full' || (diagnostics === 'duplicates' && decls.length > 1)) {
        // emit a comment that explains that there are duplicates for this declaration, and how to run a command to see more info
        const declSourceFile = decl.getSourceFile()
        const fileName = declSourceFile.getFilePath()
        const relativePath = path.relative(path.resolve(__dirname, '../../..'), fileName)

        const startLine = decl.getStartLineNumber()
        const sourceLine = `Source: ${relativePath}:${startLine}`
        testContent += `//${diagnostics === 'full' ? ` SyntaxKind: ${syntaxKindName},` : ''} ${sourceLine}
`
      }
    }
    testContent += `})
`
  }

  testContent += `})
`

  await writeFile(
    fixturePath,
    await prettierFormat(testContent, {
      ...prettierConfig,
      parser: 'typescript',
    }),
  )
}

function getTestContent(syntaxKindName, exportName, genericParams) {
  switch (syntaxKindName) {
    case 'InterfaceDeclaration':
      return `expectTypeOf<${exportName}${genericParams}>().toBeObject();
`
    case 'ClassDeclaration':
    case 'TypeAliasDeclaration':
      return `expectTypeOf<${exportName}${genericParams}>().not.toBeNever();
`
    case 'VariableDeclaration':
      return `expectTypeOf<typeof ${exportName}>().not.toBeNever();
`
    case 'FunctionDeclaration':
      return `expectTypeOf<typeof ${exportName}>().toBeFunction();
`
    case 'ModuleDeclaration':
      return `expectTypeOf<typeof ${exportName}>().not.toBeNever();
`
    case 'EnumDeclaration':
      return `expectTypeOf<typeof ${exportName}>().toBeObject();
`
    default:
      return `// FIXME: ${syntaxKindName} isn't implemented in generate.mjs yet
`
  }
}
