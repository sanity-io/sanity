import fs from 'node:fs'
import {writeFile} from 'node:fs/promises'
import path from 'node:path'

import rootJson from '@repo/test-dts-exports/package.json' with {type: 'json'}
import {format as prettierFormat, resolveConfig as resolvePrettierConfig} from 'prettier'
import {Project} from 'ts-morph'

const {dependencies} = rootJson

const fixtures = new Map()

for (const packageName of Object.keys(dependencies)) {
  const {default: packageJson} = await import(`${packageName}/package.json`, {with: {type: 'json'}})
  if (!packageJson.exports) {
    continue
  }
  for (const [key, value] of Object.entries(packageJson.exports)) {
    if (typeof value === 'object' && 'default' in value) {
      const targetFileName = path.join(packageName, value.default).replace(/\.(m|c)?js$/, '.d.ts')
      console.log(targetFileName)
      fixtures.set(path.join(packageName, key), targetFileName)
    }
  }
}

const fixturesDir = path.join(process.cwd(), 'test', 'fixtures')
if (!fs.existsSync(fixturesDir)) {
  fs.mkdirSync(fixturesDir, {recursive: true})
}

const prettierConfig = await resolvePrettierConfig(path.join(fixturesDir, 'mock.test-d.ts'))

for (const [key, value] of fixtures) {
  const fixtureName = key.replaceAll('/', '.')
  const fixturePath = path.join(fixturesDir, `${fixtureName}.test-d.ts`)

  const project = new Project()
  const sourceFile = project.addSourceFileAtPath(`../../../packages/${value}`)
  const exps = sourceFile.getExportedDeclarations()
  if (exps.size === 0) {
    console.warn(`No exports found for ${key}`)
    continue
  }

  const imports = Array.from(exps.keys()).sort((a, b) => a.localeCompare(b))

  // Generate the test content
  let testContent = `// Auto-generated by running \`pnpm generate:dts-exports\`
// If deleting the exports, for example, then please use this command to regenerate the tests
import { describe, expectTypeOf, test } from "vitest";
import type { ${imports
    .map((name) => (name === 'default' ? 'default as _default' : name))
    .join(', ')} } from "${key}";


describe(${JSON.stringify(key)}, () => {
`

  for (const name of imports) {
    const decls = exps.get(name)
    if (!decls || decls.length === 0) {
      console.warn(`No declarations found for ${name} in ${key}`)
      continue
    }
    const exportName = name === 'default' ? '_default' : name
    testContent += `test(${JSON.stringify(name)}, () => {
`

    for (const decl of decls) {
      if (decls.length > 1) {
        const declSourceFile = decl.getSourceFile()
        const fileName = declSourceFile.getFilePath()
        const relativePath = path.relative(path.resolve(process.cwd(), '../../..'), fileName)

        const startLine = decl.getStartLineNumber()
        testContent += `// Source: ${relativePath}:${startLine}
`
      }
      const genericParamsCount = decl.getTypeParameters?.().length ?? 0
      const genericParams =
        genericParamsCount > 0 ? `<${Array(genericParamsCount).fill('any').join(', ')}>` : ''
      switch (decl.getKindName()) {
        case 'InterfaceDeclaration':
          testContent += `expectTypeOf<${exportName}${genericParams}>().toBeObject();
`
          break
        case 'ClassDeclaration':
        case 'TypeAliasDeclaration':
          testContent += `expectTypeOf<${exportName}${genericParams}>().not.toBeNever();
`
          break
        case 'VariableDeclaration':
          testContent += `expectTypeOf<typeof ${exportName}>().not.toBeNever();
`
          break
        case 'FunctionDeclaration':
          testContent += `expectTypeOf<typeof ${exportName}>().toBeFunction();
`
          break
        case 'ModuleDeclaration':
          testContent += `expectTypeOf<typeof ${exportName}>().not.toBeNever();
`
          break
        case 'EnumDeclaration':
          testContent += `expectTypeOf<typeof ${exportName}>().toBeObject();
`
          break
        default:
          testContent += `// FIXME: ${decl.getKindName()} isn't implemented in generate.mjs yet
`
          break
      }
    }
    testContent += `})
`
  }

  testContent += `})
`

  await writeFile(
    fixturePath,
    await prettierFormat(testContent, {
      ...prettierConfig,
      parser: 'typescript',
    }),
  )
}
