import {constants, open} from 'node:fs/promises'
import {dirname, join} from 'node:path'

import {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'
import {readConfig} from '@sanity/codegen'
import readPkgUp from 'read-pkg-up'
import {Worker} from 'worker_threads'

import {
  type TypegenGenerateTypesWorkerData,
  type TypegenGenerateTypesWorkerMessage,
} from '../../threads/typegenGenerate'
import {TypesGeneratedTrace} from './generate.telemetry'

export interface TypegenGenerateTypesCommandFlags {
  configPath?: string
}

const generatedFileWarning = `/**
 * ---------------------------------------------------------------------------------
 * This file has been generated by Sanity TypeGen.
 * Command: \`sanity typegen generate\`
 *
 * Any modifications made directly to this file will be overwritten the next time
 * the TypeScript definitions are generated. Please make changes to the Sanity
 * schema definitions and/or GROQ queries if you need to update these types.
 *
 * For more information on how to use Sanity TypeGen, visit the official documentation:
 * https://www.sanity.io/docs/sanity-typegen
 * ---------------------------------------------------------------------------------
 */\n\n`

export default async function typegenGenerateAction(
  args: CliCommandArguments<TypegenGenerateTypesCommandFlags>,
  context: CliCommandContext,
): Promise<void> {
  const flags = args.extOptions
  const {output, workDir, telemetry} = context

  const trace = telemetry.trace(TypesGeneratedTrace)
  trace.start()

  const codegenConfig = await readConfig(flags.configPath || 'sanity-typegen.json')

  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path
  if (!rootPkgPath) {
    throw new Error('Could not find the root directory for the `sanity` package')
  }

  const workerPath = join(
    dirname(rootPkgPath),
    'lib',
    '_internal',
    'cli',
    'threads',
    'typegenGenerate.js',
  )

  const spinner = output.spinner({}).start('Generating types')

  const worker = new Worker(workerPath, {
    workerData: {
      workDir,
      schemaPath: codegenConfig.schema,
      searchPath: codegenConfig.path,
    } satisfies TypegenGenerateTypesWorkerData,
    // eslint-disable-next-line no-process-env
    env: process.env,
  })

  const typeFile = await open(
    join(process.cwd(), codegenConfig.generates),
    // eslint-disable-next-line no-bitwise
    constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY,
  )

  typeFile.write(generatedFileWarning)

  const stats = {
    files: 0,
    errors: 0,
    queries: 0,
    schemas: 0,
    unknownTypes: 0,
    size: 0,
  }

  await new Promise<void>((resolve, reject) => {
    worker.addListener('message', (msg: TypegenGenerateTypesWorkerMessage) => {
      if (msg.type === 'error') {
        if (msg.fatal) {
          trace.error(msg.error)
          reject(msg.error)
          return
        }
        const errorMessage = msg.filename
          ? `${msg.error.message} in "${msg.filename}"`
          : msg.error.message
        spinner.fail(errorMessage)
        stats.errors++
        return
      }
      if (msg.type === 'complete') {
        resolve()
        return
      }

      let fileTypeString = `// Source: ${msg.filename}\n`

      if (msg.type === 'schema') {
        stats.schemas += msg.length
        fileTypeString += `${msg.schema}\n\n`
        typeFile.write(fileTypeString)
        return
      }

      stats.files++
      for (const {queryName, query, type, unknownTypes} of msg.types) {
        fileTypeString += `// Variable: ${queryName}\n`
        fileTypeString += `// Query: ${query.replace(/(\r\n|\n|\r)/gm, '')}\n`
        fileTypeString += `${type}\n`
        stats.queries++
        stats.unknownTypes += unknownTypes
      }
      typeFile.write(`${fileTypeString}\n`)
      stats.size += Buffer.byteLength(fileTypeString)
    })
    worker.addListener('error', reject)
  })

  typeFile.close()

  trace.log({
    outputSize: stats.size,
    queryTypes: stats.queries,
    schemaTypes: stats.schemas,
    files: stats.files,
    filesWithErrors: stats.errors,
    unknownTypes: stats.unknownTypes,
  })

  trace.complete()
  if (stats.errors > 0) {
    spinner.warn(`Encountered errors in ${stats.errors} files while generating types`)
  }

  spinner.succeed(
    `Generated TypeScript types for ${stats.schemas} schema types and ${stats.queries} GROQ queries in ${stats.files} files into: ${codegenConfig.generates}`,
  )
}
