import fs from 'node:fs/promises'
import path from 'node:path'
import {fileURLToPath} from 'node:url'

import {type ReactElement} from 'react'
import {renderToStaticMarkup} from 'react-dom/server'
import readPkgUp from 'read-pkg-up'
import {type Plugin} from 'vite'

import {getSanityPkgExportAliases} from '../getBrowserAliases'
import {getStudioEnvironmentVariables} from '../getStudioEnvironmentVariables'
import {getMonorepoAliases, loadSanityMonorepo} from '../sanityMonorepo'
import {DefaultDocument} from '../components/DefaultDocument'
import {decorateIndexWithBridgeScript} from '../renderDocument'
import {sanityFaviconsPlugin} from './plugin-sanity-favicons'
import {
  sanitySchemaExtractionPlugin,
  type SchemaExtractionPluginOptions,
} from './plugin-schema-extraction'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

/**
 * Options for the Sanity Studio Vite plugin.
 * @public
 */
export interface SanityStudioPluginOptions {
  /**
   * Path to sanity.config.ts file.
   * Auto-discovered if omitted.
   */
  configPath?: string

  /**
   * Base path where Studio is mounted.
   * @defaultValue '/'
   */
  basePath?: string

  /**
   * Enable React strict mode.
   * @defaultValue true
   */
  reactStrictMode?: boolean

  /**
   * Enable schema extraction during dev.
   * Can be boolean or options object.
   * @defaultValue false
   */
  schemaExtraction?: boolean | Omit<SchemaExtractionPluginOptions, 'workDir'>
}

const VIRTUAL_ENTRY_ID = 'virtual:sanity/entry'
const VIRTUAL_HTML_ID = 'virtual:sanity/index.html'
const RESOLVED_VIRTUAL_ENTRY_ID = '\0' + VIRTUAL_ENTRY_ID
const RESOLVED_VIRTUAL_HTML_ID = '\0' + VIRTUAL_HTML_ID

/**
 * Finds the sanity.config file in the given root directory.
 * Searches for sanity.config.{mjs,js,ts,jsx,tsx} in order of preference.
 */
async function findSanityConfig(root: string): Promise<string | null> {
  const extensions = ['mjs', 'js', 'ts', 'jsx', 'tsx']
  for (const ext of extensions) {
    const configPath = path.join(root, `sanity.config.${ext}`)
    try {
      await fs.access(configPath)
      return configPath
    } catch {
      // Continue to next extension
    }
  }
  return null
}

/**
 * Normalizes a base path to ensure it starts and ends with a slash.
 */
function normalizeBasePath(basePath: string): string {
  let normalized = basePath
  if (!normalized.startsWith('/')) {
    normalized = '/' + normalized
  }
  if (!normalized.endsWith('/')) {
    normalized = normalized + '/'
  }
  return normalized
}

interface EntryModuleOptions {
  configPath: string
  basePath: string
  reactStrictMode: boolean
}

/**
 * Generates the virtual entry module that bootstraps Sanity Studio.
 */
function getVirtualEntryModule(options: EntryModuleOptions): string {
  const {configPath, basePath, reactStrictMode} = options
  return `
// Virtual entry module generated by sanity/studio plugin
import studioConfig from ${JSON.stringify(configPath)}
import {renderStudio} from "sanity"

renderStudio(
  document.getElementById("sanity"),
  studioConfig,
  {reactStrictMode: ${JSON.stringify(reactStrictMode)}, basePath: ${JSON.stringify(basePath)}}
)
`
}

interface HtmlModuleOptions {
  basePath: string
  entryPath: string
}

/**
 * Generates the virtual HTML module that serves as the Studio's index.html.
 */
function getVirtualHtmlModule(options: HtmlModuleOptions): string {
  const {basePath, entryPath} = options
  const element = DefaultDocument({basePath, entryPath: `/${entryPath}`})
  const html = renderToStaticMarkup(element as ReactElement)
  return `<!DOCTYPE html>${decorateIndexWithBridgeScript(html)}`
}

/**
 * Vite plugin that serves Sanity Studio.
 * @public
 */
export function sanityStudioPlugin(options: SanityStudioPluginOptions = {}): Plugin[] {
  const {
    configPath: configPathOption,
    basePath = '/',
    reactStrictMode = true,
    schemaExtraction = false,
  } = options

  // Will be resolved in configResolved
  let resolvedRoot: string
  let resolvedConfigPath: string | null = null
  let resolvedBasePath: string

  const plugins: Plugin[] = []

  // React plugin loader (added first, conditionally)
  plugins.push({
    name: 'sanity/studio-react-loader',
    async config(config) {
      const existingPlugins = config.plugins?.flat() || []
      const hasReact = existingPlugins.some(
        (p: any) => p?.name === 'vite:react-babel' || p?.name === 'vite:react-swc',
      )

      if (!hasReact) {
        const {default: viteReact} = await import('@vitejs/plugin-react')
        return {
          plugins: [viteReact()],
        }
      }

      return {}
    },
  })

  // Store paths for favicon plugin
  let faviconPaths: {
    customFaviconsPath: string
    defaultFaviconsPath: string
    staticUrlPath: string
  } | null = null

  // Favicons plugin
  plugins.push({
    name: 'sanity/studio-favicons',
    async configResolved(config) {
      const pkgPath = (await readPkgUp({cwd: __dirname}))?.path
      if (!pkgPath) return

      faviconPaths = {
        customFaviconsPath: path.join(config.root, 'static'),
        defaultFaviconsPath: path.join(path.dirname(pkgPath), 'static', 'favicons'),
        staticUrlPath: `${normalizeBasePath(basePath)}static`,
      }
    },
    configureServer(server) {
      if (!faviconPaths) return

      const faviconPluginInstance = sanityFaviconsPlugin(faviconPaths)
      if (typeof faviconPluginInstance.configureServer === 'function') {
        // The favicons plugin's configureServer is synchronous, but the type signature
        // allows for async. Use void to explicitly handle any potential promise.
        void faviconPluginInstance.configureServer(server)
      }
    },
  })

  // Main plugin
  plugins.push({
    name: 'sanity/studio',

    async config(config, env) {
      const root = config.root || process.cwd()
      const monorepo = await loadSanityMonorepo(root)

      const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path
      if (!sanityPkgPath) {
        throw new Error('Unable to resolve `sanity` module root')
      }

      const aliases = monorepo?.path
        ? await getMonorepoAliases(monorepo.path)
        : getSanityPkgExportAliases(sanityPkgPath)

      const envVars = getStudioEnvironmentVariables({
        prefix: 'process.env.',
        jsonEncode: true,
      })

      return {
        resolve: {
          alias: aliases,
          dedupe: ['styled-components'],
        },
        define: {
          '__SANITY_STAGING__': process.env.SANITY_INTERNAL_ENV === 'staging',
          'process.env.MODE': JSON.stringify(env.mode),
          'process.env.SC_DISABLE_SPEEDY': JSON.stringify('false'),
          ...envVars,
        },
        envPrefix: 'SANITY_STUDIO_',
      }
    },

    async configResolved(config) {
      resolvedRoot = config.root
      resolvedBasePath = normalizeBasePath(basePath)

      if (configPathOption) {
        resolvedConfigPath = path.isAbsolute(configPathOption)
          ? configPathOption
          : path.join(resolvedRoot, configPathOption)
      } else {
        resolvedConfigPath = await findSanityConfig(resolvedRoot)
      }

      if (!resolvedConfigPath) {
        throw new Error(
          `Could not find sanity.config.{ts,js,mjs,jsx,tsx} in ${resolvedRoot}. ` +
            `Either create one or specify the path via the configPath option.`,
        )
      }
    },

    resolveId(id) {
      if (id === VIRTUAL_ENTRY_ID) {
        return RESOLVED_VIRTUAL_ENTRY_ID
      }
      if (id === VIRTUAL_HTML_ID) {
        return RESOLVED_VIRTUAL_HTML_ID
      }
      return null
    },

    load(id) {
      if (id === RESOLVED_VIRTUAL_ENTRY_ID) {
        return getVirtualEntryModule({
          configPath: resolvedConfigPath!,
          basePath: resolvedBasePath,
          reactStrictMode,
        })
      }
      if (id === RESOLVED_VIRTUAL_HTML_ID) {
        return getVirtualHtmlModule({
          basePath: resolvedBasePath,
          entryPath: VIRTUAL_ENTRY_ID,
        })
      }
      return null
    },

    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          const url = req.url || '/'

          // Check if this request should be handled by the studio
          const shouldHandle =
            resolvedBasePath === '/'
              ? url === '/' || url === '/index.html'
              : url.startsWith(resolvedBasePath) || url === resolvedBasePath.slice(0, -1)

          if (!shouldHandle) {
            return next()
          }

          // For HTML requests, serve our virtual HTML
          const accept = req.headers.accept || ''
          const isHtmlRequest =
            accept.includes('text/html') ||
            url.endsWith('.html') ||
            url === resolvedBasePath ||
            url === resolvedBasePath.slice(0, -1) ||
            url === '/'

          if (isHtmlRequest) {
            try {
              let html = getVirtualHtmlModule({
                basePath: resolvedBasePath,
                entryPath: VIRTUAL_ENTRY_ID,
              })
              html = await server.transformIndexHtml(url, html)
              res.setHeader('Content-Type', 'text/html')
              res.end(html)
              return
            } catch (err) {
              return next(err)
            }
          }

          next()
        })
      }
    },
  })

  // Conditionally add schema extraction plugin
  // TODO: Enable once schema extraction plugin is fully implemented
  // if (schemaExtraction) {
  //   const extractionOptions = typeof schemaExtraction === 'object' ? schemaExtraction : {}
  //   plugins.push(sanitySchemaExtractionPlugin(extractionOptions))
  // }

  return plugins
}
