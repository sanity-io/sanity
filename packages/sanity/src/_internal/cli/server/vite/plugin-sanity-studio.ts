import fs from 'node:fs/promises'
import path from 'node:path'

import {type Plugin} from 'vite'

import {type SchemaExtractionPluginOptions} from './plugin-schema-extraction'

/**
 * Options for the Sanity Studio Vite plugin.
 * @public
 */
export interface SanityStudioPluginOptions {
  /**
   * Path to sanity.config.ts file.
   * Auto-discovered if omitted.
   */
  configPath?: string

  /**
   * Base path where Studio is mounted.
   * @defaultValue '/'
   */
  basePath?: string

  /**
   * Enable React strict mode.
   * @defaultValue true
   */
  reactStrictMode?: boolean

  /**
   * Enable schema extraction during dev.
   * Can be boolean or options object.
   * @defaultValue false
   */
  schemaExtraction?: boolean | Omit<SchemaExtractionPluginOptions, 'workDir'>
}

const VIRTUAL_ENTRY_ID = 'virtual:sanity/entry'
const VIRTUAL_HTML_ID = 'virtual:sanity/index.html'
const RESOLVED_VIRTUAL_ENTRY_ID = '\0' + VIRTUAL_ENTRY_ID
const RESOLVED_VIRTUAL_HTML_ID = '\0' + VIRTUAL_HTML_ID

/**
 * Finds the sanity.config file in the given root directory.
 * Searches for sanity.config.{mjs,js,ts,jsx,tsx} in order of preference.
 */
async function findSanityConfig(root: string): Promise<string | null> {
  const extensions = ['mjs', 'js', 'ts', 'jsx', 'tsx']
  for (const ext of extensions) {
    const configPath = path.join(root, `sanity.config.${ext}`)
    try {
      await fs.access(configPath)
      return configPath
    } catch {
      // Continue to next extension
    }
  }
  return null
}

/**
 * Normalizes a base path to ensure it starts and ends with a slash.
 */
function normalizeBasePath(basePath: string): string {
  let normalized = basePath
  if (!normalized.startsWith('/')) {
    normalized = '/' + normalized
  }
  if (!normalized.endsWith('/')) {
    normalized = normalized + '/'
  }
  return normalized
}

interface EntryModuleOptions {
  configPath: string
  basePath: string
  reactStrictMode: boolean
}

/**
 * Generates the virtual entry module that bootstraps Sanity Studio.
 */
function getVirtualEntryModule(options: EntryModuleOptions): string {
  const {configPath, basePath, reactStrictMode} = options
  return `
// Virtual entry module generated by sanity/studio plugin
import studioConfig from ${JSON.stringify(configPath)}
import {renderStudio} from "sanity"

renderStudio(
  document.getElementById("sanity"),
  studioConfig,
  {reactStrictMode: ${JSON.stringify(reactStrictMode)}, basePath: ${JSON.stringify(basePath)}}
)
`
}

/**
 * Vite plugin that serves Sanity Studio.
 * @public
 */
export function sanityStudioPlugin(options: SanityStudioPluginOptions = {}): Plugin[] {
  const {
    configPath: configPathOption,
    basePath = '/',
    reactStrictMode = true,
    schemaExtraction = false,
  } = options

  // Will be resolved in configResolved
  let resolvedRoot: string
  let resolvedConfigPath: string | null = null
  let resolvedBasePath: string

  const plugins: Plugin[] = []

  // Main plugin
  plugins.push({
    name: 'sanity/studio',

    async configResolved(config) {
      resolvedRoot = config.root
      resolvedBasePath = normalizeBasePath(basePath)

      if (configPathOption) {
        resolvedConfigPath = path.isAbsolute(configPathOption)
          ? configPathOption
          : path.join(resolvedRoot, configPathOption)
      } else {
        resolvedConfigPath = await findSanityConfig(resolvedRoot)
      }

      if (!resolvedConfigPath) {
        throw new Error(
          `Could not find sanity.config.{ts,js,mjs,jsx,tsx} in ${resolvedRoot}. ` +
            `Either create one or specify the path via the configPath option.`,
        )
      }
    },

    resolveId(id) {
      if (id === VIRTUAL_ENTRY_ID) {
        return RESOLVED_VIRTUAL_ENTRY_ID
      }
      return null
    },

    load(id) {
      if (id === RESOLVED_VIRTUAL_ENTRY_ID) {
        return getVirtualEntryModule({
          configPath: resolvedConfigPath!,
          basePath: resolvedBasePath,
          reactStrictMode,
        })
      }
      return null
    },
  })

  return plugins
}
