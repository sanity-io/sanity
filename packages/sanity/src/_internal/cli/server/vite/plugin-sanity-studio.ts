import fs from 'node:fs/promises'
import path from 'node:path'
import {fileURLToPath} from 'node:url'

import readPkgUp from 'read-pkg-up'
import {type Plugin} from 'vite'

import {getSanityPkgExportAliases} from '../getBrowserAliases'
import {getStudioEnvironmentVariables} from '../getStudioEnvironmentVariables'
import {getMonorepoAliases, loadSanityMonorepo} from '../sanityMonorepo'
import {getPossibleDocumentComponentLocations} from '../renderDocument'
import {sanityFaviconsPlugin} from './plugin-sanity-favicons'
import {
  sanitySchemaExtractionPlugin,
  type SchemaExtractionPluginOptions,
} from './plugin-schema-extraction'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

/**
 * Options for the Sanity Studio Vite plugin.
 * @public
 */
export interface SanityStudioPluginOptions {
  /**
   * Path to sanity.config.ts file.
   * Auto-discovered if omitted.
   */
  configPath?: string

  /**
   * Base path where Studio is mounted.
   * @defaultValue '/'
   */
  basePath?: string

  /**
   * Enable React strict mode.
   * @defaultValue true
   */
  reactStrictMode?: boolean

  /**
   * Enable schema extraction during dev.
   * Can be boolean or options object.
   * @defaultValue false
   */
  schemaExtraction?: boolean | Omit<SchemaExtractionPluginOptions, 'workDir'>
}

const VIRTUAL_ENTRY_ID = 'virtual:sanity/entry'
const VIRTUAL_HTML_ID = 'virtual:sanity/index.html'
const RESOLVED_VIRTUAL_ENTRY_ID = '\0' + VIRTUAL_ENTRY_ID
const RESOLVED_VIRTUAL_HTML_ID = '\0' + VIRTUAL_HTML_ID

/**
 * Finds the sanity.config file in the given root directory.
 * Searches for sanity.config.{mjs,js,ts,jsx,tsx} in order of preference.
 */
async function findSanityConfig(root: string): Promise<string | null> {
  const extensions = ['mjs', 'js', 'ts', 'jsx', 'tsx']
  for (const ext of extensions) {
    const configPath = path.join(root, `sanity.config.${ext}`)
    try {
      await fs.access(configPath)
      return configPath
    } catch {
      // Continue to next extension
    }
  }
  return null
}

/**
 * Checks if the project has a custom _document.tsx file.
 * @internal
 */
async function hasCustomDocument(root: string): Promise<boolean> {
  const locations = getPossibleDocumentComponentLocations(root)
  for (const location of locations) {
    try {
      await fs.access(location)
      return true
    } catch {
      continue
    }
  }
  return false
}

/**
 * Normalizes a base path to ensure it starts and ends with a slash.
 */
function normalizeBasePath(basePath: string): string {
  let normalized = basePath
  if (!normalized.startsWith('/')) {
    normalized = '/' + normalized
  }
  if (!normalized.endsWith('/')) {
    normalized = normalized + '/'
  }
  return normalized
}

interface EntryModuleOptions {
  configPath: string
  basePath: string
  reactStrictMode: boolean
}

/**
 * Generates the virtual entry module that bootstraps Sanity Studio.
 */
function getVirtualEntryModule(options: EntryModuleOptions): string {
  const {configPath, basePath, reactStrictMode} = options
  return `
// Virtual entry module generated by sanity/studio plugin
import studioConfig from ${JSON.stringify(configPath)}
import {renderStudio} from "sanity"

renderStudio(
  document.getElementById("sanity"),
  studioConfig,
  {reactStrictMode: ${JSON.stringify(reactStrictMode)}, basePath: ${JSON.stringify(basePath)}}
)
`
}

interface HtmlModuleOptions {
  basePath: string
  entryPath: string
  css?: string[]
}

/**
 * Gets the URL to the Sanity bridge script based on environment.
 */
function getBridgeScriptUrl(): string {
  const sanityEnv = process.env.SANITY_INTERNAL_ENV || 'production'
  return sanityEnv === 'production'
    ? 'https://core.sanity-cdn.com/bridge.js'
    : 'https://core.sanity-cdn.work/bridge.js'
}

/**
 * Global styles for the Studio HTML document.
 */
const globalStyles = `
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Medium.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 500;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-MediumItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 600;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-SemiBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 700;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBold.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 800;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-ExtraBoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: normal;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-Black.woff2") format("woff2");
  }
  @font-face {
    font-family: Inter;
    font-style: italic;
    font-weight: 900;
    font-display: swap;
    src: url("https://studio-static.sanity.io/Inter-BlackItalic.woff2") format("woff2");
  }
  html {
    @media (prefers-color-scheme: dark) {
      background-color: #13141b;
    }
    @media (prefers-color-scheme: light) {
      background-color: #ffffff;
    }
  }
  html,
  body,
  #sanity {
    height: 100%;
  }
  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
  }
`

/**
 * Global error handler script for the Studio.
 */
const errorHandlerScript = `
;(function () {
  var errorChannel = (function () {
    var subscribers = Object.create(null)
    var nextId = 0
    function subscribe(subscriber) {
      var id = nextId++
      subscribers[id] = subscriber
      return function unsubscribe() {
        delete subscribers[id]
      }
    }
    function publish(event) {
      for (var id in subscribers) {
        if (Object.hasOwn(subscribers, id)) {
          subscribers[id](event)
        }
      }
    }
    return { subscribers, publish, subscribe }
  })()

  window.__sanityErrorChannel = { subscribe: errorChannel.subscribe }

  function _handleError(event) {
    if (Object.keys(errorChannel.subscribers).length > 0) {
      errorChannel.publish(event)
    } else {
      _renderErrorOverlay(event)
    }
  }

  var ERROR_BOX_STYLE = [
    'background: #fff',
    'border-radius: 6px',
    'box-sizing: border-box',
    'color: #121923',
    'flex: 1',
    "font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue','Liberation Sans',Helvetica,Arial,system-ui,sans-serif",
    'font-size: 16px',
    'line-height: 21px',
    'margin: 0 auto',
    'max-width: 960px',
    'max-height: 90dvh',
    'overflow: auto',
    'padding: 20px',
    'width: 100%',
  ].join(';')

  var ERROR_CODE_STYLE = [
    'color: #972E2A',
    "font-family: -apple-system-ui-monospace, 'SF Mono', Menlo, Monaco, Consolas, monospace",
    'font-size: 13px',
    'line-height: 17px',
    'margin: 0',
  ].join(';')

  function _renderErrorOverlay(event) {
    var errorElement = document.querySelector('#__sanityError') || document.createElement('div')
    var error = event.error
    var colno = event.colno
    var lineno = event.lineno
    var filename = event.filename

    errorElement.id = '__sanityError'
    errorElement.innerHTML = [
      '<div style="' + ERROR_BOX_STYLE + '">',
      '<div style="font-weight: 700;">Uncaught error: ' + error.message + '</div>',
      '<div style="color: #515E72; font-size: 13px; line-height: 17px; margin: 10px 0;">' +
        filename + ':' + lineno + ':' + colno + '</div>',
      '<pre style="' + ERROR_CODE_STYLE + '">' + error.stack + '</pre>',
      '</div>',
    ].join('')

    errorElement.style.position = 'fixed'
    errorElement.style.zIndex = 1000000
    errorElement.style.top = 0
    errorElement.style.left = 0
    errorElement.style.right = 0
    errorElement.style.bottom = 0
    errorElement.style.padding = '20px'
    errorElement.style.background = 'rgba(16,17,18,0.66)'
    errorElement.style.display = 'flex'
    errorElement.style.alignItems = 'center'
    errorElement.style.justifyContent = 'center'

    document.body.appendChild(errorElement)
  }

  window.addEventListener('error', (event) => {
    _handleError({
      type: 'error',
      error: event.error,
      lineno: event.lineno,
      colno: event.colno,
      filename: event.filename
    })
  })

  window.addEventListener('unhandledrejection', (event) => {
    _handleError({
      type: 'rejection',
      error: event.reason
    })
  })
})()
`

/**
 * NoJavaScript styles for when JS is disabled.
 */
const noJsStyles = `
.sanity-app-no-js__root {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  background: #fff;
}

.sanity-app-no-js__content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  font-family: helvetica, arial, sans-serif;
}
`

/**
 * Generates the virtual HTML module that serves as the Studio's index.html.
 * Uses string templates instead of React components to avoid React compiler hook issues
 * when running in the Vite plugin context.
 */
function getVirtualHtmlModule(options: HtmlModuleOptions): string {
  const {entryPath, css = []} = options
  // TODO: Support custom _document.tsx files
  // Currently uses a string template; custom document support would require
  // dynamic import/SSR compilation which is complex in Vite plugin context.
  // The hasCustomDocument() helper is available to detect if a custom document exists.
  const normalizedEntryPath = entryPath.startsWith('/') ? entryPath : `/${entryPath}`
  const base = '/static'

  const cssLinks = css.map((href) => `<link rel="stylesheet" href="${href}">`).join('\n        ')

  const html = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <meta name="robots" content="noindex">
    <meta name="referrer" content="same-origin">
    <link rel="icon" href="${base}/favicon.ico" sizes="any">
    <link rel="icon" href="${base}/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="${base}/apple-touch-icon.png">
    <link rel="manifest" href="${base}/manifest.webmanifest">
    <title>Sanity Studio</title>
    <script>${errorHandlerScript}</script>
    ${cssLinks}
    <style>${globalStyles}</style>
    <script src="${getBridgeScriptUrl()}" async type="module" data-sanity-core></script>
  </head>
  <body>
    <div id="sanity"></div>
    <script type="module" src="${normalizedEntryPath}"></script>
    <noscript>
      <div class="sanity-app-no-js__root">
        <div class="sanity-app-no-js__content">
          <style type="text/css">${noJsStyles}</style>
          <h1>JavaScript disabled</h1>
          <p>Please <a href="https://www.enable-javascript.com/">enable JavaScript</a> in your browser and reload the page to proceed.</p>
        </div>
      </div>
    </noscript>
  </body>
</html>`

  return html
}

/**
 * Vite plugin that serves Sanity Studio.
 * @public
 */
export function sanityStudioPlugin(options: SanityStudioPluginOptions = {}): Plugin[] {
  const {
    configPath: configPathOption,
    basePath = '/',
    reactStrictMode = true,
    schemaExtraction = false,
  } = options

  // Will be resolved in configResolved
  let resolvedRoot: string
  let resolvedConfigPath: string | null = null
  let resolvedBasePath: string

  const plugins: Plugin[] = []

  // React plugin loader (added first, conditionally)
  plugins.push({
    name: 'sanity/studio-react-loader',
    async config(config) {
      const existingPlugins = config.plugins?.flat() || []
      const hasReact = existingPlugins.some(
        (p: any) => p?.name === 'vite:react-babel' || p?.name === 'vite:react-swc',
      )

      if (!hasReact) {
        const {default: viteReact} = await import('@vitejs/plugin-react')
        return {
          plugins: [viteReact()],
        }
      }

      return {}
    },
  })

  // Store paths for favicon plugin
  let faviconPaths: {
    customFaviconsPath: string
    defaultFaviconsPath: string
    staticUrlPath: string
  } | null = null

  // Favicons plugin
  plugins.push({
    name: 'sanity/studio-favicons',
    async configResolved(config) {
      const pkgPath = (await readPkgUp({cwd: __dirname}))?.path
      if (!pkgPath) return

      faviconPaths = {
        customFaviconsPath: path.join(config.root, 'static'),
        defaultFaviconsPath: path.join(path.dirname(pkgPath), 'static', 'favicons'),
        staticUrlPath: `${normalizeBasePath(basePath)}static`,
      }
    },
    configureServer(server) {
      if (!faviconPaths) return

      const faviconPluginInstance = sanityFaviconsPlugin(faviconPaths)
      if (typeof faviconPluginInstance.configureServer === 'function') {
        // The favicons plugin's configureServer is synchronous, but the type signature
        // allows for async. Use void to explicitly handle any potential promise.
        void faviconPluginInstance.configureServer(server)
      }
    },
  })

  // Main plugin
  plugins.push({
    name: 'sanity/studio',

    async config(config, env) {
      const root = config.root || process.cwd()
      const monorepo = await loadSanityMonorepo(root)

      const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path
      if (!sanityPkgPath) {
        throw new Error('Unable to resolve `sanity` module root')
      }

      const aliases = monorepo?.path
        ? await getMonorepoAliases(monorepo.path)
        : getSanityPkgExportAliases(sanityPkgPath)

      const envVars = getStudioEnvironmentVariables({
        prefix: 'process.env.',
        jsonEncode: true,
      })

      return {
        resolve: {
          alias: aliases,
          dedupe: ['styled-components'],
        },
        define: {
          '__SANITY_STAGING__': process.env.SANITY_INTERNAL_ENV === 'staging',
          'process.env.MODE': JSON.stringify(env.mode),
          'process.env.SC_DISABLE_SPEEDY': JSON.stringify('false'),
          ...envVars,
        },
        envPrefix: 'SANITY_STUDIO_',
        build: {
          rollupOptions: {
            input: {
              sanity: VIRTUAL_ENTRY_ID,
            },
          },
        },
      }
    },

    async configResolved(config) {
      resolvedRoot = config.root
      resolvedBasePath = normalizeBasePath(basePath)

      if (configPathOption) {
        resolvedConfigPath = path.isAbsolute(configPathOption)
          ? configPathOption
          : path.join(resolvedRoot, configPathOption)
      } else {
        resolvedConfigPath = await findSanityConfig(resolvedRoot)
      }

      if (!resolvedConfigPath) {
        throw new Error(
          `Could not find sanity.config.{ts,js,mjs,jsx,tsx} in ${resolvedRoot}. ` +
            `Either create one or specify the path via the configPath option.`,
        )
      }
    },

    resolveId(id) {
      // Handle both with and without leading slash (browser requests with /)
      if (id === VIRTUAL_ENTRY_ID || id === `/${VIRTUAL_ENTRY_ID}`) {
        return RESOLVED_VIRTUAL_ENTRY_ID
      }
      if (id === VIRTUAL_HTML_ID || id === `/${VIRTUAL_HTML_ID}`) {
        return RESOLVED_VIRTUAL_HTML_ID
      }
      return null
    },

    load(id) {
      if (id === RESOLVED_VIRTUAL_ENTRY_ID) {
        return getVirtualEntryModule({
          configPath: resolvedConfigPath!,
          basePath: resolvedBasePath,
          reactStrictMode,
        })
      }
      if (id === RESOLVED_VIRTUAL_HTML_ID) {
        return getVirtualHtmlModule({
          basePath: resolvedBasePath,
          entryPath: VIRTUAL_ENTRY_ID,
        })
      }
      return null
    },

    buildStart() {
      // Only emit entry chunk during actual build (not dev)
      if (this.meta.watchMode) return

      this.emitFile({
        type: 'chunk',
        id: VIRTUAL_ENTRY_ID,
        name: 'sanity',
      })
    },

    async generateBundle(_options, bundle) {
      if (this.meta.watchMode) return

      // Find the entry chunk we emitted
      const entryFile = Object.values(bundle).find(
        (file): file is import('rollup').OutputChunk =>
          file.type === 'chunk' &&
          file.name === 'sanity' &&
          file.facadeModuleId === RESOLVED_VIRTUAL_ENTRY_ID,
      )

      if (!entryFile) {
        throw new Error('Failed to find entry file in bundle')
      }

      const entryPath = [resolvedBasePath.replace(/\/+$/, ''), entryFile.fileName].join('/')

      // Collect CSS from entry and its imports
      let css: string[] = []
      const viteMetadata = (entryFile as any).viteMetadata as
        | {importedCss?: Set<string>}
        | undefined
      if (viteMetadata?.importedCss) {
        css = [...viteMetadata.importedCss]
        for (const key of entryFile.imports || []) {
          const entry = bundle[key]
          const entryViteMetadata = (entry as any)?.viteMetadata as
            | {importedCss?: Set<string>}
            | undefined
          if (entry?.type === 'chunk' && entryViteMetadata?.importedCss) {
            css.push(...entryViteMetadata.importedCss)
          }
        }
      }

      // Generate final HTML
      const html = getVirtualHtmlModule({
        basePath: resolvedBasePath,
        entryPath,
        css: css.map((c) => `${resolvedBasePath}${c}`),
      })

      this.emitFile({
        type: 'asset',
        fileName: 'index.html',
        source: html,
      })
    },

    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          const url = req.url || '/'

          // Check if this request should be handled by the studio
          const shouldHandle =
            resolvedBasePath === '/'
              ? url === '/' || url === '/index.html'
              : url.startsWith(resolvedBasePath) || url === resolvedBasePath.slice(0, -1)

          if (!shouldHandle) {
            return next()
          }

          // For HTML requests, serve our virtual HTML
          const accept = req.headers.accept || ''
          const isHtmlRequest =
            accept.includes('text/html') ||
            url.endsWith('.html') ||
            url === resolvedBasePath ||
            url === resolvedBasePath.slice(0, -1) ||
            url === '/'

          if (isHtmlRequest) {
            try {
              let html = getVirtualHtmlModule({
                basePath: resolvedBasePath,
                entryPath: VIRTUAL_ENTRY_ID,
              })
              html = await server.transformIndexHtml(url, html)
              res.setHeader('Content-Type', 'text/html')
              res.end(html)
              return
            } catch (err) {
              return next(err)
            }
          }

          next()
        })
      }
    },
  })

  // Conditionally add schema extraction plugin
  // TODO: Enable once schema extraction plugin is fully implemented
  // if (schemaExtraction) {
  //   const extractionOptions = typeof schemaExtraction === 'object' ? schemaExtraction : {}
  //   plugins.push(sanitySchemaExtractionPlugin(extractionOptions))
  // }

  return plugins
}
