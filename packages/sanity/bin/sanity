#!/usr/bin/env node
/**
 * `npx sanity`: in order for this to work, the `sanity` module should be the one
 * exposing a binary. However, the `@sanity/cli` module is the one who _actually_ ship
 * the CLI binary.
 *
 * To solve this:
 * 1. `@sanity/cli` is a dependency of the `sanity` module
 * 2. The path to this file is configured as `bin.sanity` in the `sanity` module
 * 3. This script resolves the `@sanity/cli` package, finds the path to the `sanity`
 *    binary from the `@sanity/cli` package declaration (`bin.sanity`)
 * 4. Either imports the resolved path directly (if it's a Node.js script), or spawns it
 *    (if the path specified does not point to a Node.js script)
 *
 * See `runSanityCli()` for more details on the dual approach of importing vs spawning.
 */

/* eslint-disable import/no-dynamic-require, no-process-exit */
import {readFile, open} from 'node:fs/promises'
import {createRequire} from 'node:module'
import {dirname, resolve} from 'node:path'
import {pathToFileURL} from 'node:url'
import {spawn} from 'node:child_process'

const require = createRequire(import.meta.url)

runSanityCli().catch((err) => {
  // Use setImmediate/setTimeout to throw outside the promise chain
  setImmediate(() => {
    throw err
  })
})

/**
 * Resolves the Sanity CLI binary from `@sanity/cli` and executes it in the best
 * possible way available to us, based on the module type:
 *
 * - If the binary is a Node.js script, we either `import()` or `require()` it based on
 *   the extension (cjs/mjs) or the package `type` field. This is prefered as it does
 *   not require spawning a new process.
 * - If the binary is not a Node.js script, we spawn it as a child process. On Windows,
 *   shebangs are parsed manually and the interpreter is invoked directly. stdio is
 *   inherited from the parent process.
 *
 * Note:
 * The "new" CLI is an ESM module, while the "old" CLI is CommonJS.
 * In theory, Node.js now has support for transparently mixing CommonJS and ESM, but in
 * practice we've seen some issues with this approach for the CLI specifically. Thus, we
 * explicitly check the package type and use either `import()` or `require()` accordingly.
 */
async function runSanityCli() {
  const {bin, type} = await getSanityCliBin()
  const shebang = await parseShebang(bin)

  // The optimal case: the binary is a Node.js script - import/require it directly to
  // prevent needing to spawn a new process
  if (isNodeScript(bin, shebang)) {
    if (type === 'module') {
      await import(pathToFileURL(bin).href)
    } else {
      require(bin)
    }
    return
  }

  // Fallback: spawn the binary as a child process.
  // Note: because we resolve the `bin` field from `@sanity/cli`'s package.json, the path
  // points to the actual source file, not a cmd-shim wrapper. This means we don't need the
  // full cmd-shim argument escaping that libraries like `cross-spawn` provide - we only need
  // to handle shebangs on Windows, where they are not natively supported by the OS.
  // On Unix, the OS handles shebangs natively.
  let command = bin
  let args = process.argv.slice(2)
  if (process.platform === 'win32' && shebang) {
    command = shebang.interpreter
    args = [...shebang.args, bin, ...process.argv.slice(2)]
  }

  const child = spawn(command, args, {stdio: 'inherit'})

  // Forward signals to the child process
  const signals = ['SIGINT', 'SIGTERM', 'SIGHUP']
  const signalHandlers = signals.map((signal) => {
    const handler = () => child.kill(signal)
    process.on(signal, handler)
    return {signal, handler}
  })

  try {
    const exitCode = await new Promise((resolve, reject) => {
      child.on('error', reject)
      child.on('close', (code) => resolve(code ?? 1))
    })
    process.exitCode = exitCode
  } finally {
    // Clean up signal handlers
    for (const {signal, handler} of signalHandlers) {
      process.off(signal, handler)
    }
  }
}

async function getSanityCliBin() {
  // Resolve package.json from `@sanity/cli` instead of the main export to allow
  // resolving before the package is built. Note that this might fail if `@sanity/cli`
  // does not explicitly list `./package.json` in the exports field, but since control
  // this module, this feels like a safe assumption.
  const pkgPath = require.resolve('@sanity/cli/package.json')

  let pkg
  try {
    pkg = JSON.parse(await readFile(pkgPath, 'utf8'))
  } catch (err) {
    throw new Error(`Failed to read @sanity/cli package.json: ${err.message}`)
  }

  if (!pkg.bin?.sanity) {
    throw new Error('Failed to find `bin.sanity` field in @sanity/cli package.json')
  }

  // Assuming `package.json` is located at the root of the package - anything else would
  // be… wild, unconventional, unorthodox… I'd even say… heretical.
  const cliDir = dirname(pkgPath)

  // Note that npm normalizes bin paths: `./bin/sanity` -> `bin/sanity`
  const bin = resolve(cliDir, pkg.bin.sanity)
  const type = determineModuleType(bin, pkg)
  return {bin, type}
}

/**
 * Parses the shebang from a script file and returns the interpreter and its arguments.
 * Returns `null` if the file has no shebang.
 *
 * Handles both direct paths and `env` invocations:
 * - `#!/usr/bin/node` => `{interpreter: '/usr/bin/node', args: []}`
 * - `#!/usr/bin/env node` => `{interpreter: 'node', args: []}`
 * - `#!/usr/bin/env -S node --flags` => `{interpreter: 'node', args: ['--flags']}`
 */
async function parseShebang(scriptPath) {
  let file
  try {
    file = await open(scriptPath)
  } catch (err) {
    throw new Error(
      `Failed to read CLI binary at ${scriptPath}: ${err instanceof Error ? err.message : err}`,
    )
  }

  try {
    const {buffer, bytesRead} = await file.read({length: 256})
    const content = buffer.toString('utf8', 0, bytesRead)

    if (!content.startsWith('#!')) {
      return null
    }

    const firstLine = content.slice(2, content.indexOf('\n')).trim()
    const parts = firstLine.split(/\s+/)

    if (parts[0].endsWith('/env')) {
      // `env` invocation: skip flags (e.g. `-S`) to find the actual interpreter
      const interpreterIdx = parts.findIndex((part, i) => i > 0 && !part.startsWith('-'))
      if (interpreterIdx === -1) {
        return null
      }
      return {
        interpreter: parts[interpreterIdx],
        args: parts.slice(interpreterIdx + 1),
      }
    }

    return {
      interpreter: parts[0],
      args: parts.slice(1),
    }
  } finally {
    await file.close()
  }
}

/**
 * Determines if the file at `scriptPath` is a Node.js script by checking its shebang.
 * Returns true if:
 * - The shebang interpreter is `node` (e.g., `#!/usr/bin/node`, `#!/usr/bin/env node`)
 * - The file has a `.js`, `.mjs`, or `.cjs` extension (fallback when no shebang)
 */
function isNodeScript(scriptPath, shebang) {
  if (shebang) {
    const {interpreter} = shebang
    return interpreter.endsWith('node') || interpreter.endsWith('node.exe')
  }

  // No shebang - fall back to extension check (.js, .mjs, .cjs)
  // This is not perfect - but it's better than nothing
  return /\.(m?js|cjs)$/.test(scriptPath)
}

function determineModuleType(binPath, pkgJson) {
  if (binPath.endsWith('.cjs')) {
    return 'commonjs'
  }

  if (binPath.endsWith('.mjs')) {
    return 'module'
  }

  return pkgJson.type === 'module' ? 'module' : 'commonjs'
}
