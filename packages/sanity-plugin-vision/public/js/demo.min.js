/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(2);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _client = __webpack_require__(3);
	
	var _client2 = _interopRequireDefault(_client);
	
	var _Vision = __webpack_require__(41);
	
	var _Vision2 = _interopRequireDefault(_Vision);
	
	var _Header = __webpack_require__(45);
	
	var _Header2 = _interopRequireDefault(_Header);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SanityVisionDemo = function (_React$Component) {
	  _inherits(SanityVisionDemo, _React$Component);
	
	  function SanityVisionDemo() {
	    _classCallCheck(this, SanityVisionDemo);
	
	    var _this = _possibleConstructorReturn(this, (SanityVisionDemo.__proto__ || Object.getPrototypeOf(SanityVisionDemo)).call(this));
	
	    _this.handleProjectChange = _this.handleProjectChange.bind(_this);
	    return _this;
	  }
	
	  _createClass(SanityVisionDemo, [{
	    key: 'handleProjectChange',
	    value: function handleProjectChange(event) {
	      console.log(event.target);
	    }
	  }, {
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate() {
	      return false;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var client = (0, _client2.default)({ projectId: 's2w5wbtl' });
	      return _react2.default.createElement(
	        'form',
	        { action: '#', onSubmit: this.handleProjectChange, className: 'pure-form' },
	        _react2.default.createElement(_Header2.default, null),
	        _react2.default.createElement(
	          'div',
	          { className: 'vision' },
	          _react2.default.createElement(_Vision2.default, { client: client })
	        )
	      );
	    }
	  }]);
	
	  return SanityVisionDemo;
	}(_react2.default.Component);
	
	_reactDom2.default.render(_react2.default.createElement(SanityVisionDemo, null), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = React;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = ReactDOM;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	var Patch = __webpack_require__(5);
	var Transaction = __webpack_require__(9);
	var dataMethods = __webpack_require__(10);
	var DatasetsClient = __webpack_require__(20);
	var ProjectsClient = __webpack_require__(21);
	var AssetsClient = __webpack_require__(22);
	var UsersClient = __webpack_require__(23);
	var AuthClient = __webpack_require__(24);
	var httpRequest = __webpack_require__(25);
	var getRequestOptions = __webpack_require__(39);
	
	var _require = __webpack_require__(40),
	    defaultConfig = _require.defaultConfig,
	    initConfig = _require.initConfig;
	
	function SanityClient() {
	  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;
	
	  this.config(config);
	
	  this.assets = new AssetsClient(this);
	  this.datasets = new DatasetsClient(this);
	  this.projects = new ProjectsClient(this);
	  this.users = new UsersClient(this);
	  this.auth = new AuthClient(this);
	}
	
	assign(SanityClient.prototype, dataMethods);
	assign(SanityClient.prototype, {
	  config: function config(newConfig) {
	    if (typeof newConfig === 'undefined') {
	      return this.clientConfig;
	    }
	
	    this.clientConfig = initConfig(newConfig, this.clientConfig || {});
	    return this;
	  },
	  getUrl: function getUrl(uri) {
	    return this.clientConfig.url + '/' + uri.replace(/^\//, '');
	  },
	  request: function request(options) {
	    return this.requestObservable(options).toPromise();
	  },
	  requestObservable: function requestObservable(options) {
	    return httpRequest(mergeOptions(getRequestOptions(this.clientConfig), options, { uri: this.getUrl(options.uri) }));
	  }
	});
	
	// Merge http options and headers
	function mergeOptions() {
	  for (var _len = arguments.length, opts = Array(_len), _key = 0; _key < _len; _key++) {
	    opts[_key] = arguments[_key];
	  }
	
	  var headers = opts.reduce(function (merged, options) {
	    if (!merged && !options.headers) {
	      return null;
	    }
	    return assign(merged || {}, options.headers || {});
	  }, null);
	  return assign.apply(undefined, opts.concat([headers ? { headers: headers } : {}]));
	}
	
	function createClient(config) {
	  return new SanityClient(config);
	}
	
	createClient.Patch = Patch;
	createClient.Transaction = Transaction;
	
	module.exports = createClient;
	//# sourceMappingURL=sanityClient.js.map

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend(target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	var deepAssign = __webpack_require__(6);
	var assign = __webpack_require__(4);
	var validate = __webpack_require__(8);
	var validateObject = validate.validateObject;
	var validateInsert = validate.validateInsert;
	
	function Patch(selection) {
	  var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	  this.selection = selection;
	  this.operations = assign({}, operations);
	  this.client = client;
	}
	
	assign(Patch.prototype, {
	  clone: function clone() {
	    return new Patch(this.selection, assign({}, this.operations), this.client);
	  },
	  merge: function merge(props) {
	    validateObject('merge', props);
	    return this._assign('merge', deepAssign(this.operations.merge || {}, props));
	  },
	  set: function set(props) {
	    return this._assign('set', props);
	  },
	  diffMatchPatch: function diffMatchPatch(props) {
	    validateObject('diffMatchPatch', props);
	    return this._assign('diffMatchPatch', props);
	  },
	  unset: function unset(attrs) {
	    if (!Array.isArray(attrs)) {
	      throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
	    }
	
	    this.operations = assign({}, this.operations, { unset: attrs });
	    return this;
	  },
	  setIfMissing: function setIfMissing(props) {
	    return this._assign('setIfMissing', props);
	  },
	  replace: function replace(props) {
	    validateObject('replace', props);
	    return this._set('set', { $: props }); // eslint-disable-line id-length
	  },
	  inc: function inc(props) {
	    return this._assign('inc', props);
	  },
	  dec: function dec(props) {
	    return this._assign('dec', props);
	  },
	  insert: function insert(at, selector, items) {
	    var _assign;
	
	    validateInsert(at, selector, items);
	    return this._assign('insert', (_assign = {}, _defineProperty(_assign, at, selector), _defineProperty(_assign, 'items', items), _assign));
	  },
	  append: function append(selector, items) {
	    return this.insert('after', selector + '[-1]', items);
	  },
	  prepend: function prepend(selector, items) {
	    return this.insert('before', selector + '[0]', items);
	  },
	  splice: function splice(selector, start, deleteCount, items) {
	    // Negative indexes doesn't mean the same in Sanity as they do in JS;
	    // -1 means "actually at the end of the array", which allows inserting
	    // at the end of the array without knowing its length. We therefore have
	    // to substract negative indexes by one to match JS. If you want Sanity-
	    // behaviour, just use `insert('replace', selector, items)` directly
	    var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
	    var startIndex = start < 0 ? start - 1 : start;
	    var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
	    var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
	    var rangeSelector = selector + '[' + startIndex + ':' + delRange + ']';
	    return this.insert('replace', rangeSelector, items || []);
	  },
	  serialize: function serialize() {
	    return assign(getSelection(this.selection), this.operations);
	  },
	  toJSON: function toJSON() {
	    return this.serialize();
	  },
	  commit: function commit() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	    if (!this.client) {
	      throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
	    }
	
	    var returnFirst = typeof this.selection === 'string';
	    var opts = assign({ returnFirst: returnFirst, returnDocuments: true }, options);
	    return this.client.mutate({ patch: this.serialize() }, opts);
	  },
	  reset: function reset() {
	    this.operations = {};
	    return this;
	  },
	  _set: function _set(op, props) {
	    return this._assign(op, props, false);
	  },
	  _assign: function _assign(op, props) {
	    var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	    validateObject(op, props);
	    this.operations = assign({}, this.operations, _defineProperty({}, op, assign({}, merge && this.operations[op] || {}, props)));
	    return this;
	  }
	});
	
	function getSelection(sel) {
	  if (typeof sel === 'string' || Array.isArray(sel)) {
	    return { id: sel };
	  }
	
	  if (sel && sel.query) {
	    return { query: sel.query };
	  }
	
	  var selectionOpts = ['* Dataset-prefixed document ID (<dataset/docId>)', '* Array of dataset-prefixed document IDs', '* Object containing `query`'].join('\n');
	
	  throw new Error('Unknown selection for patch - must be one of:\n\n' + selectionOpts);
	}
	
	module.exports = Patch;
	//# sourceMappingURL=patch.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObj = __webpack_require__(7);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Sources cannot be null or undefined');
		}
	
		return Object(val);
	}
	
	function assignKey(to, from, key) {
		var val = from[key];
	
		if (val === undefined || val === null) {
			return;
		}
	
		if (hasOwnProperty.call(to, key)) {
			if (to[key] === undefined || to[key] === null) {
				throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
			}
		}
	
		if (!hasOwnProperty.call(to, key) || !isObj(val)) {
			to[key] = val;
		} else {
			to[key] = assign(Object(to[key]), from[key]);
		}
	}
	
	function assign(to, from) {
		if (to === from) {
			return to;
		}
	
		from = Object(from);
	
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				assignKey(to, from, key);
			}
		}
	
		if (Object.getOwnPropertySymbols) {
			var symbols = Object.getOwnPropertySymbols(from);
	
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					assignKey(to, from, symbols[i]);
				}
			}
		}
	
		return to;
	}
	
	module.exports = function deepAssign(target) {
		target = toObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			assign(target, arguments[s]);
		}
	
		return target;
	};


/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (x) {
		var type = typeof x;
		return x !== null && (type === 'object' || type === 'function');
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var VALID_ASSET_TYPES = ['image', 'file'];
	var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];
	
	exports.dataset = function (name) {
	  if (!/^[-\w]{1,128}$/.test(name)) {
	    throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes');
	  }
	};
	
	exports.projectId = function (id) {
	  if (!/^[-a-z0-9]+$/i.test(id)) {
	    throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
	  }
	};
	
	exports.validateAssetType = function (type) {
	  if (VALID_ASSET_TYPES.indexOf(type) === -1) {
	    throw new Error('Invalid asset type: ' + type + '. Must be one of ' + VALID_ASSET_TYPES.join(', '));
	  }
	};
	
	exports.validateObject = function (op, val) {
	  if (val === null || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' || Array.isArray(val)) {
	    throw new Error(op + '() takes an object of properties');
	  }
	};
	
	exports.validateDocumentId = function (op, id) {
	  if (typeof id !== 'string' || !/^[-_a-z0-9]{1,128}\/[-_a-z0-9/]+$/i.test(id)) {
	    throw new Error(op + '() takes a document ID in format dataset/docId');
	  }
	};
	
	exports.validateInsert = function (at, selector, items) {
	  var signature = 'insert(at, selector, items)';
	  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
	    var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
	      return '"' + loc + '"';
	    }).join(', ');
	    throw new Error(signature + ' takes an "at"-argument which is one of: ' + valid);
	  }
	
	  if (typeof selector !== 'string') {
	    throw new Error(signature + ' takes a "selector"-argument which must be a string');
	  }
	
	  if (!Array.isArray(items)) {
	    throw new Error(signature + ' takes an "items"-argument which must be an array');
	  }
	};
	
	exports.hasDataset = function (config) {
	  if (!config.dataset) {
	    throw new Error('`dataset` must be provided to perform queries');
	  }
	
	  return config.dataset;
	};
	
	exports.promise = {
	  hasDataset: function hasDataset(config) {
	    return new Promise(function (resolve) {
	      return resolve(exports.hasDataset(config));
	    });
	  }
	};
	//# sourceMappingURL=validators.js.map

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	var assign = __webpack_require__(4);
	var validators = __webpack_require__(8);
	var Patch = __webpack_require__(5);
	
	var defaultMutateOptions = { returnDocuments: false };
	
	function Transaction() {
	  var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  var client = arguments[1];
	
	  this.operations = operations;
	  this.client = client;
	}
	
	assign(Transaction.prototype, {
	  clone: function clone() {
	    return new Transaction(this.operations.slice(0), this.client);
	  },
	  create: function create(doc) {
	    return this._create(doc, 'create');
	  },
	  createIfNotExists: function createIfNotExists(doc) {
	    return this._create(doc, 'createIfNotExists');
	  },
	  createOrReplace: function createOrReplace(doc) {
	    return this._create(doc, 'createOrReplace');
	  },
	  delete: function _delete(documentId) {
	    validators.validateDocumentId('delete', documentId);
	    return this._add({ delete: { id: documentId } });
	  },
	  patch: function patch(documentId, patchOps) {
	    var isBuilder = typeof patchOps === 'function';
	    var isPatch = documentId instanceof Patch;
	
	    // transaction.patch(client.patch('documentId').inc({visits: 1}))
	    if (isPatch) {
	      return this._add({ patch: documentId.serialize() });
	    }
	
	    // patch => patch.inc({visits: 1}).set({foo: 'bar'})
	    if (isBuilder) {
	      var patch = patchOps(new Patch(documentId, {}, this.client));
	      if (!(patch instanceof Patch)) {
	        throw new Error('function passed to `patch()` must return the patch');
	      }
	
	      return this._add({ patch: patch.serialize() });
	    }
	
	    return this._add({ patch: assign({ id: documentId }, patchOps) });
	  },
	  serialize: function serialize() {
	    return this.operations.slice();
	  },
	  toJSON: function toJSON() {
	    return this.serialize();
	  },
	  commit: function commit(options) {
	    if (!this.client) {
	      throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
	    }
	
	    return this.client.mutate(this.serialize(), options || defaultMutateOptions);
	  },
	  reset: function reset() {
	    this.operations = [];
	    return this;
	  },
	  _create: function _create(doc, op) {
	    if (!doc._id && !this.client) {
	      throw new Error('Document needs an _id property when transaction is create outside a client scope. ' + 'Pass `{_id: "<datasetName>:"}` to have Sanity generate an ID for you.');
	    }
	
	    validators.validateObject(op, doc);
	    var dataset = validators.hasDataset(this.client.clientConfig);
	    var mutation = _defineProperty({}, op, assign({}, doc, { _id: doc._id || dataset + '/' }));
	    return this._add(mutation);
	  },
	  _add: function _add(mut) {
	    this.operations.push(mut);
	    return this;
	  }
	});
	
	module.exports = Transaction;
	//# sourceMappingURL=transaction.js.map

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	var assign = __webpack_require__(4);
	var validators = __webpack_require__(8);
	var encodeQueryString = __webpack_require__(11);
	var Transaction = __webpack_require__(9);
	var Patch = __webpack_require__(5);
	var listen = __webpack_require__(12);
	
	var excludeFalsey = function excludeFalsey(param, defValue) {
	  var value = typeof param === 'undefined' ? defValue : param;
	  return param === false ? undefined : value;
	};
	
	var getMutationQuery = function getMutationQuery() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  return {
	    returnIds: true,
	    returnDocuments: excludeFalsey(options.returnDocuments, true),
	    visibility: options.visibility || 'sync'
	  };
	};
	
	var getQuerySizeLimit = 1948;
	
	module.exports = {
	  listen: listen,
	
	  fetch: function fetch(query, params) {
	    return this.dataRequest('query', { query: query, params: params }).then(function (res) {
	      return res.result || [];
	    });
	  },
	  getDocument: function getDocument(id) {
	    return this.request({
	      uri: '/data/doc/' + id,
	      json: true
	    }).then(function (res) {
	      return res.documents && res.documents[0];
	    });
	  },
	  create: function create(doc, options) {
	    return this._create(doc, 'create', options);
	  },
	  createIfNotExists: function createIfNotExists(doc, options) {
	    return this._create(doc, 'createIfNotExists', options);
	  },
	  createOrReplace: function createOrReplace(doc, options) {
	    return this._create(doc, 'createOrReplace', options);
	  },
	  patch: function patch(selector, operations) {
	    return new Patch(selector, operations, this);
	  },
	  delete: function _delete(documentId, options) {
	    validators.validateDocumentId('delete', documentId);
	    return this.dataRequest('mutate', { mutations: [{ delete: { id: documentId } }] }, options);
	  },
	  mutate: function mutate(mutations, options) {
	    var mut = mutations instanceof Patch ? mutations.serialize() : mutations;
	    var muts = Array.isArray(mut) ? mut : [mut];
	
	    return this.dataRequest('mutate', { mutations: muts }, options);
	  },
	  transaction: function transaction(operations) {
	    return new Transaction(operations, this);
	  },
	  dataRequest: function dataRequest(endpoint, body) {
	    var _this = this;
	
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    var isMutation = endpoint === 'mutate';
	
	    // Check if the query string is within a configured threshold,
	    // in which case we can use GET. Otherwise, use POST.
	    var strQuery = !isMutation && encodeQueryString(body);
	    var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
	    var stringQuery = useGet ? strQuery : '';
	    var returnFirst = options.returnFirst;
	
	    return validators.promise.hasDataset(this.clientConfig).then(function (dataset) {
	      return _this.request({
	        method: useGet ? 'GET' : 'POST',
	        uri: '/data/' + endpoint + '/' + dataset + stringQuery,
	        json: true,
	        body: useGet ? undefined : body,
	        query: isMutation && getMutationQuery(options)
	      });
	    }).then(function (res) {
	      if (!isMutation) {
	        return res;
	      }
	
	      var results = res.results || [];
	      if (options.returnDocuments) {
	        return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
	          return mut.document;
	        });
	      }
	
	      // Only return IDs
	      var key = returnFirst ? 'documentId' : 'documentIds';
	      var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
	        return mut.id;
	      });
	      return _defineProperty({ transactionId: res.transactionId }, key, ids);
	    });
	  },
	  _create: function _create(doc, op) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    var dataset = validators.hasDataset(this.clientConfig);
	    var mutation = _defineProperty({}, op, assign({}, doc, { _id: doc._id || dataset + '/' }));
	    var opts = assign({ returnFirst: true, returnDocuments: true }, options);
	    return this.dataRequest('mutate', { mutations: [mutation] }, opts);
	  }
	};
	//# sourceMappingURL=dataMethods.js.map

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	
	var enc = encodeURIComponent;
	
	module.exports = function (_ref) {
	  var query = _ref.query,
	      _ref$params = _ref.params,
	      params = _ref$params === undefined ? {} : _ref$params,
	      _ref$options = _ref.options,
	      options = _ref$options === undefined ? {} : _ref$options;
	
	  var qString = Object.keys(params).reduce(function (qs, param) {
	    return qs + "&" + enc("$" + param) + "=" + enc(JSON.stringify(params[param]));
	  }, "?query=" + enc(query));
	
	  return Object.keys(options).reduce(function (qs, option) {
	    // Only include the option if it is truthy
	    return options[option] ? qs + "&" + enc(option) + "=" + enc(options[option]) : qs;
	  }, qString);
	};
	//# sourceMappingURL=encodeQueryString.js.map

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	var Observable = __webpack_require__(13);
	var encodeQueryString = __webpack_require__(11);
	var validators = __webpack_require__(8);
	var pick = __webpack_require__(16);
	var defaults = __webpack_require__(17);
	
	var EventSource = typeof window !== 'undefined' && window.EventSource ? window.EventSource // Native browser EventSource
	: __webpack_require__(18); // Node.js, IE etc
	
	// Temporarily(?) needed because the node eventsource doesn't expose removeEventListener
	var removeListener = function removeListener(evtSrc, evt, handler) {
	  if (evtSrc.removeEventListener) {
	    evtSrc.removeEventListener(evt, handler, false);
	  } else {
	    evtSrc.removeListener(evt, handler);
	  }
	};
	
	var possibleOptions = ['includePreviousRevision', 'includeResult'];
	var defaultOptions = {
	  includeResult: true
	};
	
	module.exports = function listen(query, params) {
	  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  var options = defaults(opts, defaultOptions);
	  var listenOpts = pick(options, possibleOptions);
	  var qs = encodeQueryString({ query: query, params: params, options: listenOpts });
	  var dataset = validators.hasDataset(this.clientConfig);
	  var uri = this.getUrl('/data/listen/' + dataset + qs);
	  var token = this.clientConfig.token;
	  var listenFor = options.events ? options.events : ['document'];
	  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;
	
	  var es = new EventSource(uri, assign({ withCredentials: true }, token ? { headers: { 'Sanity-Token': token } } : {}));
	
	  return new Observable(function (observer) {
	    es.addEventListener('error', onError, false);
	    es.addEventListener('disconnect', onDisconnect, false);
	    listenFor.forEach(function (type) {
	      return es.addEventListener(type, onMessage, false);
	    });
	
	    function onError(err) {
	      if (err.data) {
	        observer.error(cooerceError(err));
	      } else if (es.readyState === EventSource.CLOSED) {
	        observer.complete();
	      } else if (es.readyState === EventSource.CONNECTING) {
	        emitReconnect();
	      }
	    }
	
	    function onMessage(evt) {
	      var event = parseEvent(evt);
	      return event instanceof Error ? observer.error(event) : observer.next(event);
	    }
	
	    function onDisconnect(evt) {
	      observer.complete();
	      unsubscribe();
	    }
	
	    function unsubscribe() {
	      listenFor.forEach(function (type) {
	        return removeListener(es, type, onMessage);
	      });
	      removeListener(es, 'error', onError);
	      removeListener(es, 'disconnect', onDisconnect);
	      es.close();
	    }
	
	    function emitReconnect() {
	      if (shouldEmitReconnect) {
	        observer.next({ type: 'reconnect' });
	      }
	    }
	
	    return unsubscribe;
	  });
	};
	
	function parseEvent(event) {
	  try {
	    var data = event.data && JSON.parse(event.data) || {};
	    return assign({ type: event.type }, data);
	  } catch (err) {
	    return err;
	  }
	}
	
	function cooerceError(err) {
	  if (err instanceof Error) {
	    return err;
	  }
	
	  var evt = parseEvent(err);
	  return evt instanceof Error ? evt : new Error(evt.error || 'Unknown listener error');
	}
	//# sourceMappingURL=listen.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(14).Observable;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict'; (function(fn, name) { if (true) fn(exports, module); else if (typeof self !== 'undefined') fn(name === '*' ? self : (name ? self[name] = {} : {})); })(function(exports, module) { // === Symbol Support ===
	
	function hasSymbol(name) {
	
	    return typeof Symbol === "function" && Boolean(Symbol[name]);
	}
	
	function getSymbol(name) {
	
	    return hasSymbol(name) ? Symbol[name] : "@@" + name;
	}
	
	// === Abstract Operations ===
	
	function getMethod(obj, key) {
	
	    var value = obj[key];
	
	    if (value == null)
	        return undefined;
	
	    if (typeof value !== "function")
	        throw new TypeError(value + " is not a function");
	
	    return value;
	}
	
	function getSpecies(ctor) {
	
	    var symbol = getSymbol("species");
	    return symbol ? ctor[symbol] : ctor;
	}
	
	function addMethods(target, methods) {
	
	    Object.keys(methods).forEach(function(k) {
	
	        var desc = Object.getOwnPropertyDescriptor(methods, k);
	        desc.enumerable = false;
	        Object.defineProperty(target, k, desc);
	    });
	}
	
	function cleanupSubscription(subscription) {
	
	    // Assert:  observer._observer is undefined
	
	    var cleanup = subscription._cleanup;
	
	    if (!cleanup)
	        return;
	
	    // Drop the reference to the cleanup function so that we won't call it
	    // more than once
	    subscription._cleanup = undefined;
	
	    // Call the cleanup function
	    cleanup();
	}
	
	function subscriptionClosed(subscription) {
	
	    return subscription._observer === undefined;
	}
	
	function closeSubscription(subscription) {
	
	    if (subscriptionClosed(subscription))
	        return;
	
	    subscription._observer = undefined;
	    cleanupSubscription(subscription);
	}
	
	function cleanupFromSubscription(subscription) {
	    return function(_) { subscription.unsubscribe() };
	}
	
	function Subscription(observer, subscriber) {
	
	    // Assert: subscriber is callable
	
	    // The observer must be an object
	    if (Object(observer) !== observer)
	        throw new TypeError("Observer must be an object");
	
	    this._cleanup = undefined;
	    this._observer = observer;
	
	    var start = getMethod(observer, "start");
	
	    if (start)
	        start.call(observer, this);
	
	    if (subscriptionClosed(this))
	        return;
	
	    observer = new SubscriptionObserver(this);
	
	    try {
	
	        // Call the subscriber function
	        var cleanup$0 = subscriber.call(undefined, observer);
	
	        // The return value must be undefined, null, a subscription object, or a function
	        if (cleanup$0 != null) {
	
	            if (typeof cleanup$0.unsubscribe === "function")
	                cleanup$0 = cleanupFromSubscription(cleanup$0);
	            else if (typeof cleanup$0 !== "function")
	                throw new TypeError(cleanup$0 + " is not a function");
	
	            this._cleanup = cleanup$0;
	        }
	
	    } catch (e) {
	
	        // If an error occurs during startup, then attempt to send the error
	        // to the observer
	        observer.error(e);
	        return;
	    }
	
	    // If the stream is already finished, then perform cleanup
	    if (subscriptionClosed(this))
	        cleanupSubscription(this);
	}
	
	addMethods(Subscription.prototype = {}, {
	    get closed() { return subscriptionClosed(this) },
	    unsubscribe: function() { closeSubscription(this) },
	});
	
	function SubscriptionObserver(subscription) {
	    this._subscription = subscription;
	}
	
	addMethods(SubscriptionObserver.prototype = {}, {
	
	    get closed() { return subscriptionClosed(this._subscription) },
	
	    next: function(value) {
	
	        var subscription = this._subscription;
	
	        // If the stream if closed, then return undefined
	        if (subscriptionClosed(subscription))
	            return undefined;
	
	        var observer = subscription._observer;
	
	        try {
	
	            var m$0 = getMethod(observer, "next");
	
	            // If the observer doesn't support "next", then return undefined
	            if (!m$0)
	                return undefined;
	
	            // Send the next value to the sink
	            return m$0.call(observer, value);
	
	        } catch (e) {
	
	            // If the observer throws, then close the stream and rethrow the error
	            try { closeSubscription(subscription) }
	            finally { throw e }
	        }
	    },
	
	    error: function(value) {
	
	        var subscription = this._subscription;
	
	        // If the stream is closed, throw the error to the caller
	        if (subscriptionClosed(subscription))
	            throw value;
	
	        var observer = subscription._observer;
	        subscription._observer = undefined;
	
	        try {
	
	            var m$1 = getMethod(observer, "error");
	
	            // If the sink does not support "error", then throw the error to the caller
	            if (!m$1)
	                throw value;
	
	            value = m$1.call(observer, value);
	
	        } catch (e) {
	
	            try { cleanupSubscription(subscription) }
	            finally { throw e }
	        }
	
	        cleanupSubscription(subscription);
	        return value;
	    },
	
	    complete: function(value) {
	
	        var subscription = this._subscription;
	
	        // If the stream is closed, then return undefined
	        if (subscriptionClosed(subscription))
	            return undefined;
	
	        var observer = subscription._observer;
	        subscription._observer = undefined;
	
	        try {
	
	            var m$2 = getMethod(observer, "complete");
	
	            // If the sink does not support "complete", then return undefined
	            value = m$2 ? m$2.call(observer, value) : undefined;
	
	        } catch (e) {
	
	            try { cleanupSubscription(subscription) }
	            finally { throw e }
	        }
	
	        cleanupSubscription(subscription);
	        return value;
	    },
	
	});
	
	function Observable(subscriber) {
	
	    // The stream subscriber must be a function
	    if (typeof subscriber !== "function")
	        throw new TypeError("Observable initializer must be a function");
	
	    this._subscriber = subscriber;
	}
	
	addMethods(Observable.prototype, {
	
	    subscribe: function(observer) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); 
	
	        if (typeof observer === 'function') {
	
	            observer = {
	                next: observer,
	                error: args[0],
	                complete: args[1],
	            };
	        }
	
	        return new Subscription(observer, this._subscriber);
	    },
	
	    forEach: function(fn) { var __this = this; 
	
	        return new Promise(function(resolve, reject) {
	
	            if (typeof fn !== "function")
	                return Promise.reject(new TypeError(fn + " is not a function"));
	
	            __this.subscribe({
	
	                _subscription: null,
	
	                start: function(subscription) {
	
	                    if (Object(subscription) !== subscription)
	                        throw new TypeError(subscription + " is not an object");
	
	                    this._subscription = subscription;
	                },
	
	                next: function(value) {
	
	                    var subscription = this._subscription;
	
	                    if (subscription.closed)
	                        return;
	
	                    try {
	
	                        return fn(value);
	
	                    } catch (err) {
	
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                },
	
	                error: reject,
	                complete: resolve,
	            });
	
	        });
	    },
	
	    map: function(fn) { var __this = this; 
	
	        if (typeof fn !== "function")
	            throw new TypeError(fn + " is not a function");
	
	        var C = getSpecies(this.constructor);
	
	        return new C(function(observer) { return __this.subscribe({
	
	            next: function(value) {
	
	                if (observer.closed)
	                    return;
	
	                try { value = fn(value) }
	                catch (e) { return observer.error(e) }
	
	                return observer.next(value);
	            },
	
	            error: function(e) { return observer.error(e) },
	            complete: function(x) { return observer.complete(x) },
	        }); });
	    },
	
	    filter: function(fn) { var __this = this; 
	
	        if (typeof fn !== "function")
	            throw new TypeError(fn + " is not a function");
	
	        var C = getSpecies(this.constructor);
	
	        return new C(function(observer) { return __this.subscribe({
	
	            next: function(value) {
	
	                if (observer.closed)
	                    return;
	
	                try { if (!fn(value)) return undefined }
	                catch (e) { return observer.error(e) }
	
	                return observer.next(value);
	            },
	
	            error: function(e) { return observer.error(e) },
	            complete: function() { return observer.complete() },
	        }); });
	    },
	
	    reduce: function(fn) { var __this = this; 
	
	        if (typeof fn !== "function")
	            throw new TypeError(fn + " is not a function");
	
	        var C = getSpecies(this.constructor),
	            hasSeed = arguments.length > 1,
	            hasValue = false,
	            seed = arguments[1],
	            acc = seed;
	
	        return new C(function(observer) { return __this.subscribe({
	
	            next: function(value) {
	
	                if (observer.closed)
	                    return;
	
	                var first = !hasValue;
	                hasValue = true;
	
	                if (!first || hasSeed) {
	
	                    try { acc = fn(acc, value) }
	                    catch (e) { return observer.error(e) }
	
	                } else {
	
	                    acc = value;
	                }
	            },
	
	            error: function(e) { return observer.error(e) },
	
	            complete: function() {
	
	                if (!hasValue && !hasSeed) {
	                    observer.error(new TypeError("Cannot reduce an empty sequence"));
	                    return;
	                }
	
	                observer.next(acc);
	                observer.complete();
	            },
	
	        }); });
	    },
	
	    flatMap: function(fn) { var __this = this; 
	
	        if (typeof fn !== "function")
	            throw new TypeError(fn + " is not a function");
	
	        var C = getSpecies(this.constructor);
	
	        return new C(function(observer) {
	
	            var completed = false,
	                subscriptions = [];
	
	            // Subscribe to the outer Observable
	            var outer = __this.subscribe({
	
	                next: function(value) {
	
	                    if (fn) {
	
	                        try {
	
	                            value = fn(value);
	
	                        } catch (x) {
	
	                            observer.error(x);
	                            return;
	                        }
	                    }
	
	                    // Subscribe to the inner Observable
	                    Observable.from(value).subscribe({
	
	                        _subscription: null,
	
	                        start: function(s) { subscriptions.push(this._subscription = s) },
	                        next: function(value) { observer.next(value) },
	                        error: function(e) { observer.error(e) },
	
	                        complete: function() {
	
	                            var i = subscriptions.indexOf(this._subscription);
	
	                            if (i >= 0)
	                                subscriptions.splice(i, 1);
	
	                            closeIfDone();
	                        }
	                    });
	                },
	
	                error: function(e) {
	
	                    return observer.error(e);
	                },
	
	                complete: function() {
	
	                    completed = true;
	                    closeIfDone();
	                }
	            });
	
	            function closeIfDone() {
	
	                if (completed && subscriptions.length === 0)
	                    observer.complete();
	            }
	
	            return function(_) {
	
	                subscriptions.forEach(function(s) { return s.unsubscribe(); });
	                outer.unsubscribe();
	            };
	        });
	    }
	
	});
	
	Object.defineProperty(Observable.prototype, getSymbol("observable"), {
	    value: function() { return this },
	    writable: true,
	    configurable: true,
	});
	
	addMethods(Observable, {
	
	    from: function(x) {
	
	        var C = typeof this === "function" ? this : Observable;
	
	        if (x == null)
	            throw new TypeError(x + " is not an object");
	
	        var method = getMethod(x, getSymbol("observable"));
	
	        if (method) {
	
	            var observable$0 = method.call(x);
	
	            if (Object(observable$0) !== observable$0)
	                throw new TypeError(observable$0 + " is not an object");
	
	            if (observable$0.constructor === C)
	                return observable$0;
	
	            return new C(function(observer) { return observable$0.subscribe(observer); });
	        }
	
	        if (hasSymbol("iterator") && (method = getMethod(x, getSymbol("iterator")))) {
	
	            return new C(function(observer) {
	
	                for (var __$0 = (method.call(x))[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) { var item$0 = __$1.value; 
	
	                    observer.next(item$0);
	
	                    if (observer.closed)
	                        return;
	                }
	
	                observer.complete();
	            });
	        }
	
	        if (Array.isArray(x)) {
	
	            return new C(function(observer) {
	
	                for (var i$0 = 0; i$0 < x.length; ++i$0) {
	
	                    observer.next(x[i$0]);
	
	                    if (observer.closed)
	                        return;
	                }
	
	                observer.complete();
	            });
	        }
	
	        throw new TypeError(x + " is not observable");
	    },
	
	    of: function() { for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) items.push(arguments[__$0]); 
	
	        var C = typeof this === "function" ? this : Observable;
	
	        return new C(function(observer) {
	
	            for (var i$1 = 0; i$1 < items.length; ++i$1) {
	
	                observer.next(items[i$1]);
	
	                if (observer.closed)
	                    return;
	            }
	
	            observer.complete();
	        });
	    },
	
	});
	
	Object.defineProperty(Observable, getSymbol("species"), {
	    get: function() { return this },
	    configurable: true,
	});
	
	exports.Observable = Observable;
	
	
	}, "*");
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (obj, props) {
	  return props.reduce(function (selection, prop) {
	    if (typeof obj[prop] === 'undefined') {
	      return selection;
	    }
	
	    selection[prop] = obj[prop];
	    return selection;
	  }, {});
	};
	//# sourceMappingURL=pick.js.map

/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (obj, defaults) {
	  return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
	    target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
	
	    return target;
	  }, {});
	};
	//# sourceMappingURL=defaults.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(19)


/***/ },
/* 19 */
/***/ function(module, exports) {

	/*
	   * EventSource polyfill version 0.9.6
	   * Supported by sc AmvTek srl
	   * :email: devel@amvtek.com
	 */
	;(function (global) {
	
	    if (global.EventSource && !global._eventSourceImportPrefix){
	        return;
	    }
	
	    var evsImportName = (global._eventSourceImportPrefix||'')+"EventSource";
	
	    var EventSource = function (url, options) {
	
	        if (!url || typeof url != 'string') {
	            throw new SyntaxError('Not enough arguments');
	        }
	
	        this.URL = url;
	        this.setOptions(options);
	        var evs = this;
	        setTimeout(function(){evs.poll()}, 0);
	    };
	
	    EventSource.prototype = {
	
	        CONNECTING: 0,
	
	        OPEN: 1,
	
	        CLOSED: 2,
	
	        defaultOptions: {
	
	            loggingEnabled: false,
	
	            loggingPrefix: "eventsource",
	
	            interval: 500, // milliseconds
	
	            bufferSizeLimit: 256*1024, // bytes
	
	            silentTimeout: 300000, // milliseconds
	
	            getArgs:{
	                'evs_buffer_size_limit': 256*1024
	            },
	
	            xhrHeaders:{
	                'Accept': 'text/event-stream',
	                'Cache-Control': 'no-cache',
	                'X-Requested-With': 'XMLHttpRequest'
	            }
	        },
	
	        setOptions: function(options){
	
	            var defaults = this.defaultOptions;
	            var option;
	
	            // set all default options...
	            for (option in defaults){
	
	                if ( defaults.hasOwnProperty(option) ){
	                    this[option] = defaults[option];
	                }
	            }
	
	            // override with what is in options
	            for (option in options){
	
	                if (option in defaults && options.hasOwnProperty(option)){
	                    this[option] = options[option];
	                }
	            }
	
	            // if getArgs option is enabled
	            // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
	            if (this.getArgs && this.bufferSizeLimit) {
	
	                this.getArgs['evs_buffer_size_limit'] = this.bufferSizeLimit;
	            }
	
	            // if console is not available, force loggingEnabled to false
	            if (typeof console === "undefined" || typeof console.log === "undefined") {
	
	                this.loggingEnabled = false;
	            }
	        },
	
	        log: function(message) {
	
	            if (this.loggingEnabled) {
	
	                console.log("[" + this.loggingPrefix +"]:" + message)
	            }
	        },
	
	        poll: function() {
	
	            try {
	
	                if (this.readyState == this.CLOSED) {
	                    return;
	                }
	
	                this.cleanup();
	                this.readyState = this.CONNECTING;
	                this.cursor = 0;
	                this.cache = '';
	                this._xhr = new this.XHR(this);
	                this.resetNoActivityTimer();
	
	            }
	            catch (e) {
	
	                // in an attempt to silence the errors
	                this.log('There were errors inside the pool try-catch');
	                this.dispatchEvent('error', { type: 'error', data: e.message });
	            }
	        },
	
	        pollAgain: function (interval) {
	
	            // schedule poll to be called after interval milliseconds
	            var evs = this;
	            evs.readyState = evs.CONNECTING;
	            evs.dispatchEvent('error', {
	                type: 'error',
	                data: "Reconnecting "
	            });
	            this._pollTimer = setTimeout(function(){evs.poll()}, interval||0);
	        },
	
	
	        cleanup: function() {
	
	            this.log('evs cleaning up')
	
	            if (this._pollTimer){
	                clearInterval(this._pollTimer);
	                this._pollTimer = null;
	            }
	
	            if (this._noActivityTimer){
	                clearInterval(this._noActivityTimer);
	                this._noActivityTimer = null;
	            }
	
	            if (this._xhr){
	                this._xhr.abort();
	                this._xhr = null;
	            }
	        },
	
	        resetNoActivityTimer: function(){
	
	            if (this.silentTimeout){
	
	                if (this._noActivityTimer){
	                    clearInterval(this._noActivityTimer);
	                }
	                var evs = this;
	                this._noActivityTimer = setTimeout(
	                        function(){ evs.log('Timeout! silentTImeout:'+evs.silentTimeout); evs.pollAgain(); },
	                        this.silentTimeout
	                        );
	            }
	        },
	
	        close: function () {
	
	            this.readyState = this.CLOSED;
	            this.log('Closing connection. readyState: '+this.readyState);
	            this.cleanup();
	        },
	
	        ondata: function() {
	
	            var request = this._xhr;
	
	            if (request.isReady() && !request.hasError() ) {
	                // reset the timer, as we have activity
	                this.resetNoActivityTimer();
	
	                // move this EventSource to OPEN state...
	                if (this.readyState == this.CONNECTING) {
	                    this.readyState = this.OPEN;
	                    this.dispatchEvent('open', { type: 'open' });
	                }
	
	                var buffer = request.getBuffer();
	
	                if (buffer.length > this.bufferSizeLimit) {
	                    this.log('buffer.length > this.bufferSizeLimit');
	                    this.pollAgain();
	                }
	
	                if (this.cursor == 0 && buffer.length > 0){
	
	                    // skip byte order mark \uFEFF character if it starts the stream
	                    if (buffer.substring(0,1) == '\uFEFF'){
	                        this.cursor = 1;
	                    }
	                }
	
	                var lastMessageIndex = this.lastMessageIndex(buffer);
	                if (lastMessageIndex[0] >= this.cursor){
	
	                    var newcursor = lastMessageIndex[1];
	                    var toparse = buffer.substring(this.cursor, newcursor);
	                    this.parseStream(toparse);
	                    this.cursor = newcursor;
	                }
	
	                // if request is finished, reopen the connection
	                if (request.isDone()) {
	                    this.log('request.isDone(). reopening the connection');
	                    this.pollAgain(this.interval);
	                }
	            }
	            else if (this.readyState !== this.CLOSED) {
	
	                this.log('this.readyState !== this.CLOSED');
	                this.pollAgain(this.interval);
	
	                //MV: Unsure why an error was previously dispatched
	            }
	        },
	
	        parseStream: function(chunk) {
	
	            // normalize line separators (\r\n,\r,\n) to \n
	            // remove white spaces that may precede \n
	            chunk = this.cache + this.normalizeToLF(chunk);
	
	            var events = chunk.split('\n\n');
	
	            var i, j, eventType, datas, line, retry;
	
	            for (i=0; i < (events.length - 1); i++) {
	
	                eventType = 'message';
	                datas = [];
	                parts = events[i].split('\n');
	
	                for (j=0; j < parts.length; j++) {
	
	                    line = this.trimWhiteSpace(parts[j]);
	
	                    if (line.indexOf('event') == 0) {
	
	                        eventType = line.replace(/event:?\s*/, '');
	                    }
	                    else if (line.indexOf('retry') == 0) {
	
	                        retry = parseInt(line.replace(/retry:?\s*/, ''));
	                        if(!isNaN(retry)) {
	                            this.interval = retry;
	                        }
	                    }
	                    else if (line.indexOf('data') == 0) {
	
	                        datas.push(line.replace(/data:?\s*/, ''));
	                    }
	                    else if (line.indexOf('id:') == 0) {
	
	                        this.lastEventId = line.replace(/id:?\s*/, '');
	                    }
	                    else if (line.indexOf('id') == 0) { // this resets the id
	
	                        this.lastEventId = null;
	                    }
	                }
	
	                if (datas.length) {
	                    // dispatch a new event
	                    var event = new MessageEvent(eventType, datas.join('\n'), window.location.origin, this.lastEventId);
	                    this.dispatchEvent(eventType, event);
	                }
	            }
	
	            this.cache = events[events.length - 1];
	        },
	
	        dispatchEvent: function (type, event) {
	            var handlers = this['_' + type + 'Handlers'];
	
	            if (handlers) {
	
	                for (var i = 0; i < handlers.length; i++) {
	                    handlers[i].call(this, event);
	                }
	            }
	
	            if (this['on' + type]) {
	                this['on' + type].call(this, event);
	            }
	
	        },
	
	        addEventListener: function (type, handler) {
	            if (!this['_' + type + 'Handlers']) {
	                this['_' + type + 'Handlers'] = [];
	            }
	
	            this['_' + type + 'Handlers'].push(handler);
	        },
	
	        removeEventListener: function (type, handler) {
	            var handlers = this['_' + type + 'Handlers'];
	            if (!handlers) {
	                return;
	            }
	            for (var i = handlers.length - 1; i >= 0; --i) {
	                if (handlers[i] === handler) {
	                    handlers.splice(i, 1);
	                    break;
	                }
	            }
	        },
	
	        _pollTimer: null,
	
	        _noactivityTimer: null,
	
	        _xhr: null,
	
	        lastEventId: null,
	
	        cache: '',
	
	        cursor: 0,
	
	        onerror: null,
	
	        onmessage: null,
	
	        onopen: null,
	
	        readyState: 0,
	
	        // ===================================================================
	        // helpers functions
	        // those are attached to prototype to ease reuse and testing...
	
	        urlWithParams: function (baseURL, params) {
	
	            var encodedArgs = [];
	
	            if (params){
	
	                var key, urlarg;
	                var urlize = encodeURIComponent;
	
	                for (key in params){
	                    if (params.hasOwnProperty(key)) {
	                        urlarg = urlize(key)+'='+urlize(params[key]);
	                        encodedArgs.push(urlarg);
	                    }
	                }
	            }
	
	            if (encodedArgs.length > 0){
	
	                if (baseURL.indexOf('?') == -1)
	                    return baseURL + '?' + encodedArgs.join('&');
	                return baseURL + '&' + encodedArgs.join('&');
	            }
	            return baseURL;
	        },
	
	        lastMessageIndex: function(text) {
	
	            var ln2 =text.lastIndexOf('\n\n');
	            var lr2 = text.lastIndexOf('\r\r');
	            var lrln2 = text.lastIndexOf('\r\n\r\n');
	
	            if (lrln2 > Math.max(ln2, lr2)) {
	                return [lrln2, lrln2+4];
	            }
	            return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
	        },
	
	        trimWhiteSpace: function(str) {
	            // to remove whitespaces left and right of string
	
	            var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
	            return str.replace(reTrim, '');
	        },
	
	        normalizeToLF: function(str) {
	
	            // replace \r and \r\n with \n
	            return str.replace(/\r\n|\r/g, '\n');
	        }
	
	    };
	
	    if (!isOldIE()){
	
	        EventSource.isPolyfill = "XHR";
	
	        // EventSource will send request using XMLHttpRequest
	        EventSource.prototype.XHR = function(evs) {
	
	            request = new XMLHttpRequest();
	            this._request = request;
	            evs._xhr = this;
	
	            // set handlers
	            request.onreadystatechange = function(){
	                if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
	                    if (request.status == 200 || (request.status>=300 && request.status<400)){
	                        evs.ondata();
	                    }
	                    else {
	                        request._failed = true;
	                        evs.readyState = evs.CLOSED;
	                        evs.dispatchEvent('error', {
	                            type: 'error',
	                            data: "The server responded with "+request.status
	                        });
	                        evs.close();
	                    }
	                }
	            };
	
	            request.onprogress = function () {
	            };
	
	            request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);
	
	            var headers = evs.xhrHeaders; // maybe null
	            for (var header in headers) {
	                if (headers.hasOwnProperty(header)){
	                    request.setRequestHeader(header, headers[header]);
	                }
	            }
	            if (evs.lastEventId) {
	                request.setRequestHeader('Last-Event-Id', evs.lastEventId);
	            }
	
	            request.send();
	        };
	
	        EventSource.prototype.XHR.prototype = {
	
	            useXDomainRequest: false,
	
	            _request: null,
	
	            _failed: false, // true if we have had errors...
	
	            isReady: function() {
	
	
	                return this._request.readyState >= 2;
	            },
	
	            isDone: function() {
	
	                return (this._request.readyState == 4);
	            },
	
	            hasError: function() {
	
	                return (this._failed || (this._request.status >= 400));
	            },
	
	            getBuffer: function() {
	
	                var rv = '';
	                try {
	                    rv = this._request.responseText || '';
	                }
	                catch (e){}
	                return rv;
	            },
	
	            abort: function() {
	
	                if ( this._request ) {
	                    this._request.abort();
	                }
	            }
	        };
	    }
	    else {
	
		EventSource.isPolyfill = "IE_8-9";
	
	        // patch EventSource defaultOptions
	        var defaults = EventSource.prototype.defaultOptions;
	        defaults.xhrHeaders = null; // no headers will be sent
	        defaults.getArgs['evs_preamble'] = 2048 + 8;
	
	        // EventSource will send request using Internet Explorer XDomainRequest
	        EventSource.prototype.XHR = function(evs) {
	
	            request = new XDomainRequest();
	            this._request = request;
	
	            // set handlers
	            request.onprogress = function(){
	                request._ready = true;
	                evs.ondata();
	            };
	
	            request.onload = function(){
	                this._loaded = true;
	                evs.ondata();
	            };
	
	            request.onerror = function(){
	                this._failed = true;
	                evs.readyState = evs.CLOSED;
	                evs.dispatchEvent('error', {
	                    type: 'error',
	                    data: "XDomainRequest error"
	                });
	            };
	
	            request.ontimeout = function(){
	                this._failed = true;
	                evs.readyState = evs.CLOSED;
	                evs.dispatchEvent('error', {
	                    type: 'error',
	                    data: "XDomainRequest timed out"
	                });
	            };
	
	            // XDomainRequest does not allow setting custom headers
	            // If EventSource has enabled the use of GET arguments
	            // we add parameters to URL so that server can adapt the stream...
	            var reqGetArgs = {};
	            if (evs.getArgs) {
	
	                // copy evs.getArgs in reqGetArgs
	                var defaultArgs = evs.getArgs;
	                    for (var key in defaultArgs) {
	                        if (defaultArgs.hasOwnProperty(key)){
	                            reqGetArgs[key] = defaultArgs[key];
	                        }
	                    }
	                if (evs.lastEventId){
	                    reqGetArgs['evs_last_event_id'] = evs.lastEventId;
	                }
	            }
	            // send the request
	
	            request.open('GET', evs.urlWithParams(evs.URL,reqGetArgs));
	            request.send();
	        };
	
	        EventSource.prototype.XHR.prototype = {
	
	            useXDomainRequest: true,
	
	            _request: null,
	
	            _ready: false, // true when progress events are dispatched
	
	            _loaded: false, // true when request has been loaded
	
	            _failed: false, // true if when request is in error
	
	            isReady: function() {
	
	                return this._request._ready;
	            },
	
	            isDone: function() {
	
	                return this._request._loaded;
	            },
	
	            hasError: function() {
	
	                return this._request._failed;
	            },
	
	            getBuffer: function() {
	
	                var rv = '';
	                try {
	                    rv = this._request.responseText || '';
	                }
	                catch (e){}
	                return rv;
	            },
	
	            abort: function() {
	
	                if ( this._request){
	                    this._request.abort();
	                }
	            }
	        };
	    }
	
	    function MessageEvent(type, data, origin, lastEventId) {
	
	        this.bubbles = false;
	        this.cancelBubble = false;
	        this.cancelable = false;
	        this.data = data || null;
	        this.origin = origin || '';
	        this.lastEventId = lastEventId || '';
	        this.type = type || 'message';
	    }
	
	    function isOldIE () {
	
	        //return true if we are in IE8 or IE9
	        return (window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined)) ? true : false;
	    }
	
	    global[evsImportName] = EventSource;
	})(this);


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	var validate = __webpack_require__(8);
	
	function DatasetsClient(client) {
	  this.request = client.request.bind(client);
	}
	
	assign(DatasetsClient.prototype, {
	  create: function create(name) {
	    return this._modify('PUT', name);
	  },
	  delete: function _delete(name) {
	    return this._modify('DELETE', name);
	  },
	  list: function list() {
	    return this.request({ uri: '/datasets' });
	  },
	  _modify: function _modify(method, name) {
	    validate.dataset(name);
	    return this.request({ method: method, uri: '/datasets/' + name });
	  }
	});
	
	module.exports = DatasetsClient;
	//# sourceMappingURL=datasetsClient.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	
	function ProjectsClient(client) {
	  this.client = client;
	}
	
	assign(ProjectsClient.prototype, {
	  list: function list() {
	    return this.client.request({ uri: '/projects' });
	  },
	  getById: function getById(id) {
	    return this.client.request({ uri: '/projects/' + id });
	  }
	});
	
	module.exports = ProjectsClient;
	//# sourceMappingURL=projectsClient.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	var validators = __webpack_require__(8);
	
	function AssetsClient(client) {
	  this.client = client;
	}
	
	var ASSET_TYPES_TO_ENDPOINT = {
	  image: 'images',
	  file: 'files'
	};
	
	assign(AssetsClient.prototype, {
	  upload: function upload(assetType, file) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    validators.validateAssetType(assetType);
	
	    var dataset = validators.hasDataset(this.client.clientConfig);
	
	    var customHeaders = 'contentType' in options ? { 'Content-Type': options.contentType } : {};
	
	    var assetEndpointSegment = ASSET_TYPES_TO_ENDPOINT[assetType];
	
	    return this.client.requestObservable({
	      method: 'POST',
	      headers: assign({
	        Accept: 'application/json'
	      }, customHeaders),
	      uri: '/assets/' + assetEndpointSegment + '/' + dataset,
	      body: file,
	      json: false,
	      timeout: 0
	    }).map(function (event) {
	      if (event.type !== 'response') {
	        return event;
	      }
	      return assign({}, event, {
	        body: JSON.parse(event.body)
	      });
	    });
	  }
	});
	
	module.exports = AssetsClient;
	//# sourceMappingURL=assetsClient.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	
	function UsersClient(client) {
	  this.client = client;
	}
	
	assign(UsersClient.prototype, {
	  getById: function getById(id) {
	    return this.client.request({ uri: '/users/' + id });
	  }
	});
	
	module.exports = UsersClient;
	//# sourceMappingURL=usersClient.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	
	function AuthClient(client) {
	  this.client = client;
	}
	
	assign(AuthClient.prototype, {
	  getLoginProviders: function getLoginProviders() {
	    return this.client.request({ uri: '/auth/providers' });
	  },
	  logout: function logout() {
	    return this.client.request({ uri: '/auth/logout' });
	  }
	});
	
	module.exports = AuthClient;
	//# sourceMappingURL=authClient.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/* eslint-disable no-empty-function, no-process-env */
	var request = __webpack_require__(27); // `request` in node, `xhr` in browsers
	var queryString = __webpack_require__(35);
	var Observable = __webpack_require__(13);
	var assign = __webpack_require__(4);
	
	var debug = (process.env.DEBUG || '').indexOf('sanity') !== -1;
	
	var log = function log() {};
	if (true) {
	  log = __webpack_require__(36)('sanity:client');
	}
	
	module.exports = function httpRequest(options) {
	  if (options.query) {
	    options.uri += '?' + queryString.stringify(options.query);
	  }
	
	  if (debug) {
	    log('HTTP %s %s', options.method || 'GET', options.uri);
	    if (options.method === 'POST' && options.body) {
	      log('Request body: %s', JSON.stringify(options.body, null, 2));
	    }
	  }
	
	  var observable = new Observable(function (observer) {
	
	    var opts = assign({}, options, {
	      beforeSend: function beforeSend(req) {
	        if (options.beforeSend) {
	          options.beforeSend(req);
	        }
	
	        // Todo: shim over node/browser differences
	        if ('upload' in req && 'onprogress' in req.upload) {
	          req.upload.onprogress = handleProgress('upload');
	        }
	
	        if ('onprogress' in req) {
	          req.onprogress = handleProgress('download');
	        }
	
	        req.onabort = function () {
	          observer.next({ type: 'abort' });
	          observer.complete();
	        };
	      }
	    });
	
	    var req = request(opts, function (err, res, body) {
	      if (err) {
	        observer.error(err);
	        return;
	      }
	
	      log('Response code: %s', res.statusCode);
	      if (debug && body) {
	        log('Response body: %s', stringifyBody(body, res));
	      }
	
	      var isHttpError = res.statusCode >= 400;
	
	      if (isHttpError && body) {
	        var msg = (body.errors ? body.errors.map(function (error) {
	          return error.message;
	        }) : []).concat([body.error, body.message]).filter(Boolean).join('\n');
	
	        var error = new Error(msg || httpError(res));
	        error.responseBody = stringifyBody(body, res);
	        error.statusCode = res.statusCode;
	        observer.error(error);
	        return;
	      } else if (isHttpError) {
	        var httpErr = new Error(httpError(res));
	        httpErr.statusCode = res.statusCode;
	        observer.error(httpErr);
	        return;
	      }
	
	      observer.next({ type: 'response', body: body });
	      observer.complete();
	    });
	
	    return function () {
	      return req.abort();
	    };
	
	    function handleProgress(stage) {
	      return function (event) {
	        var percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
	        observer.next({
	          type: 'progress',
	          stage: stage,
	          percent: percent
	        });
	      };
	    }
	  });
	
	  observable.toPromise = function () {
	    var last = void 0;
	    return observable.forEach(function (value) {
	      last = value;
	    }).then(function () {
	      return last.body;
	    });
	  };
	  return observable;
	};
	
	function httpError(res) {
	  return 'Server responded with HTTP ' + res.statusCode + ' ' + (res.statusMessage || '') + ', no description';
	}
	
	function stringifyBody(body, res) {
	  var contentType = (res.headers['content-type'] || '').toLowerCase();
	  var isJson = contentType.indexOf('application/json') !== -1;
	  return isJson ? JSON.stringify(body, null, 2) : body;
	}
	//# sourceMappingURL=request.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(28)


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var window = __webpack_require__(29)
	var isFunction = __webpack_require__(30)
	var parseHeaders = __webpack_require__(31)
	var xtend = __webpack_require__(34)
	
	module.exports = createXHR
	createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
	createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest
	
	forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
	    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
	        options = initParams(uri, options, callback)
	        options.method = method.toUpperCase()
	        return _createXHR(options)
	    }
	})
	
	function forEachArray(array, iterator) {
	    for (var i = 0; i < array.length; i++) {
	        iterator(array[i])
	    }
	}
	
	function isEmpty(obj){
	    for(var i in obj){
	        if(obj.hasOwnProperty(i)) return false
	    }
	    return true
	}
	
	function initParams(uri, options, callback) {
	    var params = uri
	
	    if (isFunction(options)) {
	        callback = options
	        if (typeof uri === "string") {
	            params = {uri:uri}
	        }
	    } else {
	        params = xtend(options, {uri: uri})
	    }
	
	    params.callback = callback
	    return params
	}
	
	function createXHR(uri, options, callback) {
	    options = initParams(uri, options, callback)
	    return _createXHR(options)
	}
	
	function _createXHR(options) {
	    if(typeof options.callback === "undefined"){
	        throw new Error("callback argument missing")
	    }
	
	    var called = false
	    var callback = function cbOnce(err, response, body){
	        if(!called){
	            called = true
	            options.callback(err, response, body)
	        }
	    }
	
	    function readystatechange() {
	        if (xhr.readyState === 4) {
	            loadFunc()
	        }
	    }
	
	    function getBody() {
	        // Chrome with requestType=blob throws errors arround when even testing access to responseText
	        var body = undefined
	
	        if (xhr.response) {
	            body = xhr.response
	        } else {
	            body = xhr.responseText || getXml(xhr)
	        }
	
	        if (isJson) {
	            try {
	                body = JSON.parse(body)
	            } catch (e) {}
	        }
	
	        return body
	    }
	
	    var failureResponse = {
	                body: undefined,
	                headers: {},
	                statusCode: 0,
	                method: method,
	                url: uri,
	                rawRequest: xhr
	            }
	
	    function errorFunc(evt) {
	        clearTimeout(timeoutTimer)
	        if(!(evt instanceof Error)){
	            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
	        }
	        evt.statusCode = 0
	        return callback(evt, failureResponse)
	    }
	
	    // will load the data & process the response in a special response object
	    function loadFunc() {
	        if (aborted) return
	        var status
	        clearTimeout(timeoutTimer)
	        if(options.useXDR && xhr.status===undefined) {
	            //IE8 CORS GET successful response doesn't have a status field, but body is fine
	            status = 200
	        } else {
	            status = (xhr.status === 1223 ? 204 : xhr.status)
	        }
	        var response = failureResponse
	        var err = null
	
	        if (status !== 0){
	            response = {
	                body: getBody(),
	                statusCode: status,
	                method: method,
	                headers: {},
	                url: uri,
	                rawRequest: xhr
	            }
	            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
	                response.headers = parseHeaders(xhr.getAllResponseHeaders())
	            }
	        } else {
	            err = new Error("Internal XMLHttpRequest Error")
	        }
	        return callback(err, response, response.body)
	    }
	
	    var xhr = options.xhr || null
	
	    if (!xhr) {
	        if (options.cors || options.useXDR) {
	            xhr = new createXHR.XDomainRequest()
	        }else{
	            xhr = new createXHR.XMLHttpRequest()
	        }
	    }
	
	    var key
	    var aborted
	    var uri = xhr.url = options.uri || options.url
	    var method = xhr.method = options.method || "GET"
	    var body = options.body || options.data || null
	    var headers = xhr.headers = options.headers || {}
	    var sync = !!options.sync
	    var isJson = false
	    var timeoutTimer
	
	    if (options.json === true) {
	        isJson = true
	        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
	        if (method !== "GET" && method !== "HEAD") {
	            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
	            body = JSON.stringify(options.body)
	        }
	    }
	
	    xhr.onreadystatechange = readystatechange
	    xhr.onload = loadFunc
	    xhr.onerror = errorFunc
	    // IE9 must have onprogress be set to a unique function.
	    xhr.onprogress = function () {
	        // IE must die
	    }
	    xhr.ontimeout = errorFunc
	    xhr.open(method, uri, !sync, options.username, options.password)
	    //has to be after open
	    if(!sync) {
	        xhr.withCredentials = !!options.withCredentials
	    }
	    // Cannot set timeout with sync request
	    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
	    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
	    if (!sync && options.timeout > 0 ) {
	        timeoutTimer = setTimeout(function(){
	            aborted=true//IE9 may still call readystatechange
	            xhr.abort("timeout")
	            var e = new Error("XMLHttpRequest timeout")
	            e.code = "ETIMEDOUT"
	            errorFunc(e)
	        }, options.timeout )
	    }
	
	    if (xhr.setRequestHeader) {
	        for(key in headers){
	            if(headers.hasOwnProperty(key)){
	                xhr.setRequestHeader(key, headers[key])
	            }
	        }
	    } else if (options.headers && !isEmpty(options.headers)) {
	        throw new Error("Headers cannot be set on an XDomainRequest object")
	    }
	
	    if ("responseType" in options) {
	        xhr.responseType = options.responseType
	    }
	
	    if ("beforeSend" in options &&
	        typeof options.beforeSend === "function"
	    ) {
	        options.beforeSend(xhr)
	    }
	
	    xhr.send(body)
	
	    return xhr
	
	
	}
	
	function getXml(xhr) {
	    if (xhr.responseType === "document") {
	        return xhr.responseXML
	    }
	    var firefoxBugTakenEffect = xhr.status === 204 && xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
	    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
	        return xhr.responseXML
	    }
	
	    return null
	}
	
	function noop() {}


/***/ },
/* 29 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {
	    module.exports = window;
	} else if (typeof global !== "undefined") {
	    module.exports = global;
	} else if (typeof self !== "undefined"){
	    module.exports = self;
	} else {
	    module.exports = {};
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = isFunction
	
	var toString = Object.prototype.toString
	
	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(32)
	  , forEach = __webpack_require__(33)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }
	
	module.exports = function (headers) {
	  if (!headers)
	    return {}
	
	  var result = {}
	
	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))
	
	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )
	
	  return result
	}

/***/ },
/* 32 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;
	
	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}
	
	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};
	
	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(30)
	
	module.exports = forEach
	
	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty
	
	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }
	
	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}
	
	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}
	
	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}
	
	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	var encode = function encode(param) {
	  return encodeURIComponent(param);
	};
	
	function queryString(params) {
	  var reduceQueryParam = function reduceQueryParam(qs, param) {
	    if (typeof params[param] === 'undefined') {
	      return qs;
	    }
	
	    return qs.concat(encode(param) + '=' + encode(params[param]));
	  };
	
	  return Object.keys(params).reduce(reduceQueryParam, []).join('&');
	}
	
	exports.stringify = queryString;
	//# sourceMappingURL=queryString.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(37);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if ('env' in (typeof process === 'undefined' ? {} : process)) {
	    r = process.env.DEBUG;
	  }
	  
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug.debug = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(38);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting
	    args = exports.formatArgs.apply(self, args);
	
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';
	
	var tokenHeader = 'Sanity-Token';
	var projectHeader = 'Sanity-Project-ID';
	
	module.exports = function (config) {
	  var headers = {};
	
	  if (config.token) {
	    headers[tokenHeader] = config.token;
	  }
	
	  if (!config.useProjectHostname && config.projectId) {
	    headers[projectHeader] = config.projectId;
	  }
	
	  return {
	    headers: headers,
	    timeout: 'timeout' in config ? config.timeout : 15000,
	    withCredentials: true,
	    json: true
	  };
	};
	//# sourceMappingURL=requestOptions.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(4);
	var validate = __webpack_require__(8);
	
	var defaultConfig = exports.defaultConfig = {
	  apiHost: 'https://api.sanity.io',
	  useProjectHostname: true
	};
	
	exports.initConfig = function (config, prevConfig) {
	  var newConfig = assign({}, defaultConfig, prevConfig, config);
	  var projectBased = newConfig.useProjectHostname;
	
	  if (typeof Promise === 'undefined') {
	    // @todo add help url?
	    throw new Error('No native `Promise`-implementation found, polyfill needed');
	  }
	
	  if (projectBased && !newConfig.projectId) {
	    throw new Error('Configuration must contain `projectId`');
	  }
	
	  if (projectBased) {
	    validate.projectId(newConfig.projectId);
	  }
	
	  if (newConfig.dataset) {
	    validate.dataset(newConfig.dataset);
	  }
	
	  var hostParts = newConfig.apiHost.split('://', 2);
	  var protocol = hostParts[0];
	  var host = hostParts[1];
	
	  if (newConfig.useProjectHostname) {
	    newConfig.url = protocol + '://' + newConfig.projectId + '.' + host + '/v1';
	  } else {
	    newConfig.url = newConfig.apiHost + '/v1';
	  }
	
	  return newConfig;
	};
	//# sourceMappingURL=config.js.map

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _VisionContainer = __webpack_require__(42);
	
	var _VisionContainer2 = _interopRequireDefault(_VisionContainer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Used outside of Sanity projects
	var Vision = function (_Component) {
	  _inherits(Vision, _Component);
	
	  function Vision() {
	    _classCallCheck(this, Vision);
	
	    return _possibleConstructorReturn(this, (Vision.__proto__ || Object.getPrototypeOf(Vision)).apply(this, arguments));
	  }
	
	  _createClass(Vision, [{
	    key: 'getChildContext',
	    value: function getChildContext() {
	      return { client: this.props.client };
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(_VisionContainer2.default, null);
	    }
	  }]);
	
	  return Vision;
	}(_react.Component);
	
	Vision.propTypes = {
	  client: _react.PropTypes.shape({ fetch: _react.PropTypes.func }).isRequired
	};
	
	Vision.childContextTypes = {
	  client: _react.PropTypes.shape({ fetch: _react.PropTypes.func }).isRequired
	};
	
	module.exports = Vision;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _ErrorDialog = __webpack_require__(43);
	
	var _ErrorDialog2 = _interopRequireDefault(_ErrorDialog);
	
	var _request = __webpack_require__(44);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _LoadingContainer2 = __webpack_require__(46);
	
	var _LoadingContainer3 = _interopRequireDefault(_LoadingContainer2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Loads the most basic data from a Sanity project
	var VisionContainer = function (_LoadingContainer) {
	  _inherits(VisionContainer, _LoadingContainer);
	
	  function VisionContainer() {
	    _classCallCheck(this, VisionContainer);
	
	    return _possibleConstructorReturn(this, (VisionContainer.__proto__ || Object.getPrototypeOf(VisionContainer)).apply(this, arguments));
	  }
	
	  _createClass(VisionContainer, [{
	    key: 'getSubscriptions',
	    value: function getSubscriptions() {
	      return [(0, _request2.default)(this, { uri: '/datasets' }, 'datasets')];
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      if (this.state.error) {
	        return _react2.default.createElement(_ErrorDialog2.default, {
	          heading: 'An error occured while loading project data',
	          error: this.state.error
	        });
	      }
	
	      return _react2.default.createElement(
	        'code',
	        null,
	        _react2.default.createElement(
	          'pre',
	          null,
	          JSON.stringify(this.state, null, 2)
	        )
	      );
	    }
	  }]);
	
	  return VisionContainer;
	}(_LoadingContainer3.default);
	
	VisionContainer.contextTypes = {
	  client: _react.PropTypes.shape({ fetch: _react.PropTypes.func }).isRequired
	};
	
	exports.default = VisionContainer;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function ErrorDialog(props) {
	  return _react2.default.createElement(
	    'div',
	    { className: 'error' },
	    _react2.default.createElement(
	      'h2',
	      null,
	      props.heading
	    ),
	    _react2.default.createElement(
	      'pre',
	      null,
	      _react2.default.createElement(
	        'code',
	        null,
	        props.error.message || props.error
	      )
	    )
	  );
	}
	
	ErrorDialog.propTypes = {
	  heading: _react.PropTypes.string,
	  error: _react.PropTypes.oneOfType(['Error', 'string'])
	};
	
	ErrorDialog.defaultProps = {
	  heading: 'An error occured'
	};
	
	exports.default = ErrorDialog;

/***/ },
/* 44 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	exports.default = function (comp, opts, key) {
	  return comp.context.client.requestObservable(opts).filter(function (event) {
	    return event.type === 'response';
	  }).map(function (event) {
	    return event.body;
	  }).subscribe({
	    next: function next(val) {
	      return comp.setState(_defineProperty({}, key, val));
	    },
	    error: function error(_error) {
	      return comp.setState({ error: _error });
	    }
	  });
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Header;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Header() {
	  return _react2.default.createElement(
	    "div",
	    { className: "header" },
	    _react2.default.createElement(
	      "div",
	      { className: "home-menu pure-menu pure-menu-horizontal" },
	      _react2.default.createElement(
	        "a",
	        { className: "pure-menu-heading", href: "" },
	        "SanityVision"
	      ),
	      _react2.default.createElement(
	        "ul",
	        { className: "pure-menu-list" },
	        _react2.default.createElement(
	          "li",
	          { className: "pure-menu-item pure-menu-selected" },
	          _react2.default.createElement("input", { type: "text", placeholder: "Project ID", required: true }),
	          _react2.default.createElement(
	            "button",
	            { type: "submit", className: "pure-button pure-button-primary" },
	            "Save"
	          )
	        )
	      )
	    )
	  );
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Yeah, inheritance and all that. Deal with it.
	var LoadingContainer = function (_React$PureComponent) {
	  _inherits(LoadingContainer, _React$PureComponent);
	
	  function LoadingContainer() {
	    _classCallCheck(this, LoadingContainer);
	
	    var _this = _possibleConstructorReturn(this, (LoadingContainer.__proto__ || Object.getPrototypeOf(LoadingContainer)).call(this));
	
	    if (!_this.getSubscriptions) {
	      throw new Error(_this.constructor.name + ' extended LoadingContainer but did not define a getSubscriptions() method');
	    }
	
	    _this.subscriptions = [];
	    _this.state = {};
	    return _this;
	  }
	
	  _createClass(LoadingContainer, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.subscriptions = this.getSubscriptions();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      while (this.subscriptions.length) {
	        this.subscriptions.pop().unsubscribe();
	      }
	    }
	  }]);
	
	  return LoadingContainer;
	}(_react2.default.PureComponent);
	
	exports.default = LoadingContainer;

/***/ }
/******/ ]);
//# sourceMappingURL=demo.min.js.map