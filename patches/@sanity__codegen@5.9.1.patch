diff --git a/dist/typescript/typeGenerator.js b/dist/typescript/typeGenerator.js
index f3bf08daed7749b88b5798f3452ac9689ffc9c6e..781f90fbe9f02fe27a6169a9a5775a4b019e2775 100644
--- a/dist/typescript/typeGenerator.js
+++ b/dist/typescript/typeGenerator.js
@@ -200,21 +200,73 @@ import { QueryEvaluationError } from './types.js';
         });
         const program = t.program([]);
         let code = '';
+        
+        // Check if ArrayOf is used in schema types
+        let arrayOfUsed = false;
+        const visited = new WeakSet();
+        const checkForArrayOf = (node, depth = 0) => {
+            if (!node) return;
+            // Prevent stack overflow on deeply nested structures
+            if (depth > 100) return;
+            
+            const isObject = typeof node === 'object';
+            // Prevent infinite recursion on circular structures
+            if (isObject) {
+                if (visited.has(node)) return;
+                visited.add(node);
+            }
+            
+            if (t.isTSTypeReference(node) && t.isIdentifier(node.typeName) && node.typeName.name === 'ArrayOf') {
+                arrayOfUsed = true;
+                return;
+            }
+            // Recursively check child nodes
+            if (Array.isArray(node)) {
+                node.forEach(child => checkForArrayOf(child, depth + 1));
+            } else if (isObject) {
+                Object.values(node).forEach(value => checkForArrayOf(value, depth + 1));
+            }
+        };
+        
         for (const declaration of schemaTypeDeclarations){
             program.body.push(declaration.ast);
             code += declaration.code;
+            // Check if this declaration uses ArrayOf
+            checkForArrayOf(declaration.tsType);
         }
         program.body.push(allSanitySchemaTypesDeclaration.ast);
         code += allSanitySchemaTypesDeclaration.code;
         program.body.push(internalReferenceSymbol.ast);
         code += internalReferenceSymbol.code;
-        program.body.push(arrayOfDeclaration.ast);
-        code += arrayOfDeclaration.code;
+        
+        // Only add ArrayOf if it's actually used
+        if (arrayOfUsed) {
+            program.body.push(arrayOfDeclaration.ast);
+            code += arrayOfDeclaration.code;
+        }
+        
         const evaluatedModules = await TypeGenerator.getEvaluatedModules({
             ...options,
             schemaTypeDeclarations,
             schemaTypeGenerator: this.getSchemaTypeGenerator(options)
         });
+        
+        // Check if any query result types use ArrayOf before adding them
+        if (!arrayOfUsed) {
+            for (const { queries } of evaluatedModules){
+                for (const query of queries){
+                    checkForArrayOf(query.tsType);
+                    if (arrayOfUsed) break;
+                }
+                if (arrayOfUsed) break;
+            }
+            // Add ArrayOf before query types if needed
+            if (arrayOfUsed) {
+                program.body.push(arrayOfDeclaration.ast);
+                code += arrayOfDeclaration.code;
+            }
+        }
+        
         for (const { queries } of evaluatedModules){
             for (const query of queries){
                 program.body.push(query.ast);
